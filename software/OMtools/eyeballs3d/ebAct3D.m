% ebAct3D.m: Called by 'eyeballs3D' to perform all the callback actions%% Written by: Jonathan Jacobs%             March 2002 - May 2005 (last mod: 05/11/05)% Files necessary for proper operation:%   'eyeballs3d', 'ebAct3D.m', 'datscale.m', 'd2pt.m', 'axispad.m',%   'xyplotsettings.m', 'ebdatacheck.m'% Major updates and fixes:% 27 Nov 02: Added alignment crosshairs. May eventually make them%  2 Dec 02: Added 'h.crossH' variable; allow turning crosshairs on/off%            The wform, monitor and control windows created at proper size,%              rather than resizing them after creation.% 29 May 03: Massive redesign of GUI, relocation of many controls%            Added user-customizable XY plot settings.%            'play' reads settings from XY plot's axis and applies values%              to XY plot playback%  2 Jun 03: Major revision now allows loading of new data w/o having to%              close and re-run 'eyeballs3d'%  5 Jun 03: User can now select arrays from the base workspace for XY plot% 16 Jul 03: Added optional display of stimulus data% 14 Oct 03: Added rubberband zoom% 12 Jan 05: Rewrote movie-making code, prefs. reorganized movie prefs.%            Render animation using 'zbuffer' workaround for 'OpenGL' bug.%            User can now specify QT (if available), AVI, or series of JPEGs% 21 Jan 05: Eyeball and waveform windows are now easily resizable via%              slider/text box controls% 28 Jan 05: Thanks to effing Microsoft's crap handling of non-native graphics%					and movie formats, eyeballs now can be rendered w/o grid lines%              so the drastically reduced quality in PowerPoint is not as easily%              noticable.% 01 Feb 05: scale values are stored in the wf FIGURE'S 'UserData' now,%              rather than in that for the individual AXES'.%              This fixes the necessity of the axes being displayed in the wf%              window for scaling to be available.% 02 Feb 05: added extra cells to wh.wf_axXY 'UserData' field as placeholders%              for the phase plane data arrays to enable stepping through%              the data ONLY AFTER it has been played at least once.% 09 May 05: zillions of little fixes. wf window resizes properly and is drawn%              at the proper size at startup. cosmetic rejiggering of axis sizes and%              positions when resizing the wf window. 'Stop' slider restored to%              proper position following cancellation of playback.%              Adjusting start/current/stop sliders when XY plot is enabled, but%              before 1st playback no longer causes a crash.%              'xyplotsettings' has been extensively updated.% June 2019: Gutted and modernised for HG2 and better OOP techniques (sorta)%              Added live scrolling to all the sliders.%              Expanded preferences, now in unified window. %              Now uses popup menu to interact with rd/datstat.              % valid commands ('buttName' arg string):%   about, rbzoom, resize, speed, eyelight, eyeliner%   h.start_txt, h.start_sli, h.stop_txt, h.stop_sli%   h.cur_txt, h.cur_sli, f_cur, f_start, f_stop%   xy_setup, play!, hvt_update%   color, crosshairs, tormrkr, wf_draw%   load_data, eb3dprefs, done!function ebAct3D(buttName)%% get goinpersistent ebtempresult %#ok<PSET> %%% time to eliminate this crapgo=gco;g=grapconsts;degstr=char(176);%pmstr=char(177);% MUST be presentcfig=findwind('Eye Monitor Control');if ~ishandle(cfig),disp('Control Window does not exist. Yikes.'); return; endefig=findwind('Eye Monitor');if ~ishandle(efig),disp('Eyeballs Window does not exist. Yikes.'); return; endwfig=findwind('Waveform Monitor');if ~ishandle(wfig),disp('Waveform Window does not exist. Yikes.'); return; end% optionalpfig=findwind('Preferences');sfig=findwind('Data Scaling & Offset');xyfig=findwind('XY Plot settings');% Retrieve the handles for the control window objects.% They were declared in 'eyeballs3d'.ch=cfig.UserData;if strcmpi(buttName,'focusgained')   select_emdata(ch.availDataH,'refresh');      returnend% retrieve the handles for the eyeball window objects.% They were declared in 'eyeballs3d'.eh=efig.UserData;btxtstr=eh.btxt.String;% is initialized in eyeballs3dd=ch.availDataH.UserData;if isstruct(d) && isfield(d,'data')   d=d.data;endif ~isa(d,'emData')   if ~isempty(d)      rh=evalin('base','rh;');      lh=evalin('base','lh;');      rv=evalin('base','rv;');      lv=evalin('base','lv;');      rt=evalin('base','rt;');      lt=evalin('base','lt;');      st=evalin('base','st;');      sv=evalin('base','sv;');      samp_freq=evalin('base','samp_freq;');   else      rh=zeros(10,1); lh=zeros(10,1);      rv=zeros(10,1); lv=zeros(10,1);      rt=zeros(10,1); lt=zeros(10,1);      st=zeros(10,1); sv=zeros(10,1);      samp_freq=1;   endelse   rh=d.lh.pos; lh=d.lh.pos;   rv=d.rv.pos; lv=d.lv.pos;   rt=d.rt.pos; lt=d.lt.pos;   st=d.st.pos; sv=d.sv.pos;   samp_freq = d.samp_freq;end% make sure we have the most recent prefspr=ch.eb3dPrefsBH.UserData;livemonitor=ch.livemonBH.Value;playstep=fix(str2double(ch.decimateH.String));% Retrieve the handles for the waveform window objects. They will be all% empty gobjects when initialized in 'eyeballs3D'. Almost immediately after% initialization, 'ebAct3D('wf_draw')' is called and the handles get% their proper values. There is a fine line between tricky and skanky.planes      =wfig.UserData{1};wh          =wfig.UserData{2};o_and_s     =wfig.UserData{3};wh.wf_ax_inited=wfig.UserData{4};eyeliner=ch.eyelinerBH.Value;eyelight=ch.eyelightBH.Value;eyeColor=eh.od.UserData;% Because we could be working with data loaded after the initial% setup of the controls, we must reset the controls' max rangedatlen=length(lh);ch.start_sli.Max=datlen;ch.stop_sli.Max=datlen;ch.cur_sli.Max=datlen;startpt=round(ch.start_sli.Value);if startpt>datlen,startpt=1;ch.start_sli.Value=startpt;endstoppt=round(ch.stop_sli.Value);if stoppt>datlen,stoppt=datlen;ch.stop_sli.Value=stoppt;endcurpt=round(ch.cur_sli.Value);if curpt>datlen,curpt=startpt;ch.cur_sli.Value=curpt;end%%%fps=samp_freq/playstep;t=(1:length(lh))/samp_freq;% Four possible axes to draw: hor, vrt, tor and phase plane (ppl)plotHOR = strfind(planes,'h'); if isempty(plotHOR),plotHOR=0; endplotVRT = strfind(planes,'v'); if isempty(plotVRT),plotVRT=0; endplotTOR = strfind(planes,'t'); if isempty(plotTOR),plotTOR=0; endplotHOR = plotHOR & ch.plotHORh.Value;plotVRT = plotVRT & ch.plotVRTh.Value;plotTOR = plotTOR & ch.plotTORh.Value;plotXY  = ch.plotXYh.Value;numplanes=sum(plotHOR+plotVRT+plotTOR);num_ax=2*numplanes;% since XY uses only one axisnumplanes=numplanes+sum(plotXY);if plotXY, num_ax=num_ax+1; end%% offset & scale% Data scale and offset is checked/performed EVERY time ebAct3D% is called, to guarantee that the most up-to-date modifications are% being used.%% If the scaling and offset window is open, the offset & scaling% factors will be read directly from its controls.% If it is NOT open, check to see if the wf window has been initialized.% If it has, there are previously set o&s values stored in the 'UserData'.% If the window is brand new, then initialize o&s values to 0 & 1.if ishandle(sfig)   % get the o/s control handles   hlist=sfig.UserData;   rh_scaleH=hlist(1);   rv_scaleH=hlist(2);   rt_scaleH=hlist(3);   rh_offsetH=hlist(4);  rv_offsetH=hlist(5);  rt_offsetH=hlist(6);   lh_scaleH=hlist(7);   lv_scaleH=hlist(8);   lt_scaleH=hlist(9);   lh_offsetH=hlist(10); lv_offsetH=hlist(11); lt_offsetH=hlist(12);      lh_scale=str2double(lh_scaleH.String);   rh_scale=str2double(rh_scaleH.String);   lv_scale=str2double(lv_scaleH.String);   rv_scale=str2double(rv_scaleH.String);   lt_scale=str2double(lt_scaleH.String);   rt_scale=str2double(rt_scaleH.String);      lh_offset=str2double(lh_offsetH.String);   rh_offset=str2double(rh_offsetH.String);   lv_offset=str2double(lv_offsetH.String);   rv_offset=str2double(rv_offsetH.String);   lt_offset=str2double(lt_offsetH.String);   rt_offset=str2double(rt_offsetH.String);   elseif wh.wf_ax_inited   offset = o_and_s{1}; scale = o_and_s{2};   rh_scale=scale(1,1); rh_offset=offset(1,1);   lh_scale=scale(1,2); lh_offset=offset(1,2);   rv_scale=scale(2,1); rv_offset=offset(2,1);   lv_scale=scale(2,2); lv_offset=offset(2,2);   rt_scale=scale(3,1); rt_offset=offset(3,1);   lt_scale=scale(3,2); lt_offset=offset(3,2);   else   lh_scale=1; lv_scale=1; lt_scale=1; lh_offset=0; lv_offset=0; lt_offset=0;   rh_scale=1; rv_scale=1; rt_scale=1; rh_offset=0; rv_offset=0; rt_offset=0;endif plotHOR   lhs=lh*lh_scale+lh_offset;   rhs=rh*rh_scale+rh_offset;   maxRHS=max(rhs(startpt:stoppt)); minRHS=min(rhs(startpt:stoppt));   maxLHS=max(lhs(startpt:stoppt)); minLHS=min(lhs(startpt:stoppt));   [minRHS, maxRHS] = axispad(minRHS,maxRHS);   [minLHS, maxLHS] = axispad(minLHS,maxLHS);else   minRHS=0; maxRHS=0;   minLHS=0; maxLHS=0;endif plotVRT   lvs=lv*lv_scale+lv_offset;   rvs=rv*rv_scale+rv_offset;   maxRVS=max(rvs(startpt:stoppt)); minRVS=min(rvs(startpt:stoppt));   maxLVS=max(lvs(startpt:stoppt)); minLVS=min(lvs(startpt:stoppt));   [minRVS, maxRVS] = axispad(minRVS,maxRVS);   [minLVS, maxLVS] = axispad(minLVS,maxLVS);else   minRVS=0; maxRVS=0;   minLVS=0; maxLVS=0;endif plotTOR   lts=lt*lt_scale+lt_offset;   rts=rt*rt_scale+rt_offset;   maxLTS=max(lts(startpt:stoppt)); minLTS=min(lts(startpt:stoppt));   maxRTS=max(rts(startpt:stoppt)); minRTS=min(rts(startpt:stoppt));   [minRTS, maxRTS] = axispad(minRTS,maxRTS);   [minLTS, maxLTS] = axispad(minLTS,maxLTS);else   minRTS=0; maxRTS=0;   minLTS=0; maxLTS=0;end%% %%%% callback functions %%%%%if strcmpi(buttName,'about')   aboutStr = {'Eyeballs3D -- Version 5.0,  June 2019';      ' ';      'Written by Jonathan Jacobs, Ph.D. (jxj24@case.edu)';      ' ';      'Ocular-Motor Neurophysiology Lab (www.OMLAB.org)';      'VA Medical Center, Cleveland, OH';      ' ';      'Depts. of Neurology (School of Medicine)';      '       and Biomedical Engineering';      'Case Western Reserve University';      ' ';      'All rights reserved. All wrongs reversed.';      '(copyleft) 2002-2019';      ' '};   msgbox(aboutStr,'About "Eyeballs"')         elseif strcmpi(buttName,'set_idstr')   temp=nameclean(go.String);   btxtstr = strrep(temp,'\','');   if isempty(btxtstr)      btxtstr = {'DD_OMLAB'};   end   eh.btxt.String=btxtstr; %necessary?   pr.btxtstr=btxtstr;   pr=eb3dprefs('refresh_pr');   ch.eb3dPrefsBH.UserData=pr;   elseif strcmpi(buttName,'idtxtcolor')   a=whatcolor(go.Value);   pr.btxtcolor=g.rgb{a.index};   eh.btxt.Color=pr.btxtcolor;   pr=eb3dprefs('refresh_pr');   ch.eb3dPrefsBH.UserData=pr;   elseif strcmpi(buttName,'idtxtsize')   pr.btxtsize=str2double(go.String);   eh.btxt.FontSize=pr.btxtsize;   pr=eb3dprefs('refresh_pr');   ch.eb3dPrefsBH.UserData=pr;         elseif strcmpi(buttName,'rbzoom')   %% rb_zoom   if go.Value==1      go.String='WF zoom is ON';      figure(wfig)      zoom on   else      go.String='WF zoom is OFF';      figure(wfig)      zoom off      % update all the damn sliders and text boxes; make sure all axes are equal      xlims=get(gca,'XLim')*samp_freq;      ch.start_sli.Value=xlims(1);      ebAct3D('start_sli');      ch.stop_sli.Value=xlims(2);      ebAct3D('stop_sli');   end      elseif contains(buttName,'change_bg')   %% change_bg   if go.Value==1      wfig.Color='k';      for ii=1:4         try            wh.wf_ax(ii,1).Color='k';            wh.wf_ax(ii,1).XColor='w';            wh.wf_ax(ii,1).YColor='w';            wh.wf_ax(ii,1).Title.Color='w';            wh.wf_ax(ii,2).Color='k';            wh.wf_ax(ii,2).XColor='w';            wh.wf_ax(ii,2).YColor='w';            wh.wf_ax(ii,1).Title.Color='w';         catch         end      end   else      wfig.Color=g.rgb{g.OFFWHITE};      for ii=1:4         try            wh.wf_ax(ii,1).Color='w';            wh.wf_ax(ii,1).XColor=g.rgb{g.DKGRAY};            wh.wf_ax(ii,1).YColor=g.rgb{g.DKGRAY};            wh.wf_ax(ii,1).Title.Color=g.rgb{g.DKGRAY};            wh.wf_ax(ii,2).Color='w';            wh.wf_ax(ii,2).XColor=g.rgb{g.DKGRAY};            wh.wf_ax(ii,2).YColor=g.rgb{g.DKGRAY};            wh.wf_ax(ii,2).Title.Color=g.rgb{g.DKGRAY};         catch         end      end   end   wfig.UserData{2}=wh; %%% needed?      elseif contains(buttName,'eyecolor')   %% eyecolor   pr=eb3dprefs('refresh_pr');   color=whatcolor(pr.eyeColorH.Value);   ebmap = ones(128,3);   eb_size=ch.eb_size_sli.Value;   if eb_size >= 0.8      ebmap(127:128,:) = zeros(2,3);      ebmap(119:126,1) = color.rgb(1);      ebmap(119:126,2) = color.rgb(2);      ebmap(119:126,3) = color.rgb(3);   elseif eb_size >= 0.5      ebmap(126:128,:) = zeros(3,3);      ebmap(117:125,1) = color.rgb(1);      ebmap(117:125,2) = color.rgb(2);      ebmap(117:125,3) = color.rgb(3);   end   ebmap(ebmap>1)=1;   ebmap(ebmap<0)=0;      eh.od.UserData=color.rgb;   efig.Colormap=ebmap;   efig.UserData=eh;   pr.eyeColor=color.rgb;   ch.eb3dPrefsBH.UserData=pr;      elseif contains(buttName,'lincolor')   %% lincolor   pr=eb3dprefs('refresh_pr');   % if gco is 'Defaults', set all line colors   % otherwise just the   chan=go.Tag;      if isempty(chan) % "Defaults" button      dflt = {[0 0 1],[0 1 0];[0 0 1],[0 1 0]; ...         [ 0 0 1],[0 1 0];[1 0 0],[1 0 0]};      for ii=1:4         for jj=1:2            if ishandle(wh.linH(ii,jj))               wh.linH(ii,jj).Color = dflt{ii,jj};            end         end      end   else      p=go.UserData(1);      e=go.UserData(2);      wh.linH(p,e).Color = pr.([chan 'Color']);   end   ch.eb3dPrefsBH.UserData=pr;         elseif contains(buttName,'resize')   %% resize   if strcmpi(buttName(8:9),'eb')      if strcmpi(buttName(11:13),'sli')         eb_size = ch.eb_size_sli.Value;         ch.eb_size_txt.String=num2str(eb_size);   %% 2?  or 3?      elseif strcmpi(buttName(11:13),'txt')         eb_size=str2double(ch.eb_size_txt.String);         if isempty(eb_size) || (eb_size>1) || (eb_size<0.5)            eb_size=ch.eb_size_sli.Value;            ch.eb_size_txt.String=num2str(eb_size);         end         ch.eb_size_sli.Value=eb_size;      end      windH=efig;      wscale=eb_size;      maxwidth=570; maxheight=264;         elseif strcmpi(buttName(8:9),'wf')      if strcmpi(buttName(11:13),'sli')         wf_size = ch.wf_size_sli.Value;         ch.wf_size_txt.String=num2str(wf_size,3);   %% 2?  or 3?      elseif strcmpi(buttName(11:13), 'txt')         wf_size = str2double(ch.wf_size_txt.String);         if isempty(wf_size) || (wf_size>1) || (wf_size<0.5)            wf_size=ch.wf_size_sli.Value;            ch.wf_size_txt.String=num2str(wf_size,3);         end         ch.wf_size_sli.Value=wf_size;      end      windH=wfig;      wscale=wf_size;      maxwidth=300;      maxheightlist=[280 540 670 810];      %% [255 507 640 780]      maxheight=maxheightlist(numplanes);   end      % Get the position of the target window and find its center.   % We will resize around the center so window appears to shrink/grow   % equally in all directions. neato.   wpos=windH.Position;   x0=wpos(1); y0=wpos(2); width=wpos(3); height=wpos(4);   center = [x0+width/2, y0+height/2];   new_wid = maxwidth*wscale;   new_hgt = maxheight*wscale;   new_x0  = center(1)-new_wid/2;   new_y0  = center(2)-new_hgt/2;   windH.Position=[new_x0, new_y0, new_wid, new_hgt];      % will we worry about the size of the text in the title, x/y labels?   % would be nice if smallifying windows below some thresh reduced the   % text to a more appropriate size. ditto for embigulating them.   % the children of the waveform window are axes (from 1 to 7 depending   % on how many dimensions are being displayed).   if windH==wfig      if wscale>0.85         titleFSize=14; xyFSize=12;      elseif wscale>0.7         titleFSize=12; xyFSize=10;      elseif wscale>0.6         titleFSize=10; xyFSize=8;      elseif wscale>=0.5         titleFSize=8; xyFSize=6;      end            axlist=windH.Children;      for ax=1:length(axlist)         titleH=axlist(ax).Title;         %tfontsize = get(titleH,'FontSize');         titleH.FontSize=titleFSize;         xlabelH=axlist(ax).XLabel;         %xfontsize = get(xlabelH,'FontSize');         xlabelH.FontSize=xyFSize;         ylabelH = axlist(ax).YLabel;         %yfontsize = get(ylabelH,'FontSize');         ylabelH.FontSize=xyFSize;      end   end      % And just for fun, we substitute a less complex eyeball if the   % window starts feeling crowded.   if windH==efig      ebmap=ones(128,3);      if wscale >= 0.8         [z,y,x]=sphere(40);         ebmap(127:128,:) = zeros(2,3);         ebmap(119:126,1) = eyeColor(1);         ebmap(119:126,2) = eyeColor(2);         ebmap(119:126,3) = eyeColor(3);      elseif wscale >= 0.5         [z,y,x]=sphere(24);         ebmap(126:128,:) = zeros(3,3);         ebmap(117:125,1) = eyeColor(1);         ebmap(117:125,2) = eyeColor(2);         ebmap(117:125,3) = eyeColor(3);      end      ebmap(ebmap>1)=1;      ebmap(ebmap<0)=0;            figure(efig)      temp=surf(x,y,z,x,'Visible','off');      cdata=temp.CData;      delete(temp)      set(eh.od,'XData',x,'YData',y,'ZData',z,'CData',cdata)      set(eh.os,'XData',x,'YData',y,'ZData',z,'CData',cdata)      efig.Colormap=ebmap;   end      elseif contains(buttName,'speed')   % link the decimate and fps values   fps=str2double(ch.fpsH.String);   dec=str2double(ch.decimateH.String);      if strcmpi(buttName(7),'d')      fps=fix(samp_freq/dec);      ch.fpsH.String=num2str(fps,'%d');   elseif strcmpi(buttName(7),'f')      dec=fix(samp_freq/fps);      ch.decimateH.String=num2str(dec,'%d');   end      elseif strcmpi(buttName,'eyelight')   ouLightH=ch.eyelightBH.UserData;   odLightH=ouLightH(1);   osLightH=ouLightH(2);   if eyelight==1      axes(eh.odSocket)      odLightH = camlight(0,10);      axes(eh.osSocket)      osLightH = camlight(0,10);      ch.eyelightBH.UserData=[odLightH osLightH];   else      delete(odLightH);      delete(osLightH);   end   axes(eh.overlay)      elseif strcmpi(buttName,'eyeliner')   if eyeliner==0      eh.os.LineStyle='none';      eh.od.LineStyle='none';   else      eh.os.LineStyle=':';      eh.od.LineStyle=':';   end      elseif strcmpi(buttName,'start_txt')   %%% start, stop, cur sliders & text   startpt = str2double(ch.start_txt.String);   if isempty(startpt), startpt=round(ch.start_sli.Value); end   ch.start_sli.Value=startpt;   ebAct3D('h.start_sli')      elseif strcmpi(buttName,'start_sli')   if startpt>=stoppt, startpt=stoppt-1; end   startpt = max(startpt,1);   startpt=fix(startpt);   ch.start_sli.Value=startpt;   ch.start_txt.String=num2str(startpt);   ch.start_txt2.String=num2str(startpt/samp_freq,3);   %%%curpt = max(startpt,curpt);   ebAct3D('cur_sli')   if plotHOR      wh.wf_axLH.XLim=[startpt/samp_freq stoppt/samp_freq];      wh.wf_axRH.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLHS~=maxLHS, wh.wf_axLH.YLim=[minLHS maxLHS]; end      if minRHS~=maxRHS, wh.wf_axRH.YLim=[minRHS maxRHS]; end   end   if plotVRT      wh.wf_axLV.XLim=[startpt/samp_freq stoppt/samp_freq];      wh.wf_axRV.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLVS~=maxLVS, wh.wf_axLV.YLim=[minLVS maxLVS]; end      if minRVS~=maxRVS, wh.wf_axRV.YLim=[minRVS maxRVS]; end   end   if plotTOR      wh.wf_axLT.XLim=[startpt/samp_freq stoppt/samp_freq];      wh.wf_axRT.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLTS~=maxLTS, wh.wf_axLT.YLim=[minLTS maxLTS]; end      if minRTS~=maxRTS, wh.wf_axRT.YLim=[minRTS maxRTS]; end   end      elseif strcmpi(buttName,'stop_txt')   stoppt = str2double(ch.stop_txt.String);   if isempty(stoppt), stoppt=round(ch.stop_sli.Value,3); end   ch.stop_sli.Value=stoppt;   ebAct3D('h.stop_sli')      elseif strcmpi(buttName,'stop_sli')   %% stop_sli   if stoppt<=startpt, stoppt=startpt+1; end   stoppt=min(stoppt,datlen);   stoppt=round(stoppt);   ch.stop_sli.Value=stoppt;   ch.stop_txt.String=num2str(stoppt);   ch.stop_txt2.String=num2str(stoppt/samp_freq,3);   %%%curpt = min(stoppt,curpt);   ebAct3D('cur_sli')   if plotHOR      wh.wf_axLH.XLim=[startpt/samp_freq stoppt/samp_freq];      wh.wf_axRH.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLHS~=maxLHS, wh.wf_axLH.YLim=[minLHS maxLHS]; end      if minRHS~=maxRHS, wh.wf_axRH.YLim=[minRHS maxRHS]; end   end   if plotVRT      wh.wf_axLV.XLim=[startpt/samp_freq stoppt/samp_freq];      wh.wf_axRV.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLVS~=maxLVS, wh.wf_axLV.YLim=[minLVS maxLVS]; end      if minRVS~=maxRVS, wh.wf_axRV.YLim=[minRVS maxRVS]; end   end   if plotTOR      wh.wf_axLT.XLim=[startpt/samp_freq stoppt/samp_freq];      wh.wf_axRT.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLTS~=maxLTS, wh.wf_axLT.YLim=[minLTS maxLTS]; end      if minRTS~=maxRTS, wh.wf_axRT.YLim=[minRTS maxRTS]; end   end      elseif strcmpi(buttName(1:3), 'cur')        %% 'h.cur_txt', 'h.cur_sli'   if strcmpi(buttName(5:7), 'txt')      curpt=str2double(ch.cur_txt.String);   end   if isempty(curpt),curpt=round(ch.cur_sli.Value); end   if curpt<startpt, curpt=startpt; end   if curpt>stoppt,  curpt=stoppt; end   curpt=fix(curpt);   ch.cur_sli.Value=curpt;   ch.cur_txt.String=num2str(curpt);   ch.cur_txt2.String=num2str(curpt/samp_freq,3);   eh.osSocket.View=[lhs(curpt)+90 -lvs(curpt)];   eh.odSocket.View=[rhs(curpt)+90 -rvs(curpt)];   prev_tor(1)=eh.osSocket.UserData;   prev_tor(2)=eh.odSocket.UserData;   rotate( eh.os,[1 0 0],     lts(curpt)-prev_tor(1) );   rotate( eh.od,[1 0 0],     rts(curpt)-prev_tor(2) );   rotate( eh.osMrkr,[1 0 0], lts(curpt)-prev_tor(1) );   rotate( eh.odMrkr,[1 0 0], rts(curpt)-prev_tor(2) );   prev_tor = [lts(curpt) rts(curpt)];   eh.osSocket.UserData=prev_tor(1);   eh.odSocket.UserData=prev_tor(2);   ebAct3D('hvt_update')      elseif strcmpi(buttName(1), 'f')   if strcmpi(buttName(3:5), 'cur')      new_cur=str2double(ch.cur_txt2.String)*samp_freq;      ch.cur_txt.String=num2str(new_cur);      ebAct3D('h.cur_txt')   elseif strcmpi(buttName(3:6), 'stop')      new_stop=str2double(ch.stop_txt2.String)*samp_freq;      ch.stop_txt.String=num2str(new_stop);      ebAct3D('h.stop_txt')   elseif strcmpi(buttName(3:7), 'start')      new_start=str2double(ch.start_txt2.String)*samp_freq;      ch.start_txt.String=num2str(new_start);      ebAct3D('h.start_txt')   end      elseif strcmpi(buttName,'xy_setup')   xyplotenabled=ch.plotXYh.Value;   if xyplotenabled      xyplotsettings('initialize')   end      elseif strcmpi(buttName,'play!')  %% play  pbH=ch.cur_sli;   if pbH.UserData==1      disp('Playback in progress. Please wait.')      return   end   pbH.UserData=1;   % allocate space for the movie(s)   %rect = [245 7 96 96]; capture only OS      pr.movie_fps=30;      make_eb_movie=ch.eb_movieBH.Value;   if make_eb_movie      [fn,pn]=uiputfile({'*.mov;*.avi;*.*'},'Save the eyeball movie as:');      if fn==0, return, end      [fn,~]=strtok(fn,'.');      eb_mov=VideoWriter([pn fn '.mp4'], 'MPEG-4');      eb_mov.FrameRate=pr.movie_fps;      eb_mov.Quality=75;      open(eb_mov);   end      make_wf_movie=ch.wf_movieBH.Value;   if make_wf_movie      [fn,pn]=uiputfile({'*.mov;*.avi;*.*'},'Save the eyeball movie as:');      if fn==0, return, end      [fn,~]=strtok(fn,'.');      wf_mov=VideoWriter([pn fn '.mp4'], 'MPEG-4');      wf_mov.FrameRate=pr.movie_fps;      wf_mov.Quality=75;      open(wf_mov);   end      % clear the torsions   prev_tor(1)=eh.osSocket.UserData;   prev_tor(2)=eh.odSocket.UserData;   rotate( eh.os,[1 0 0],     prev_tor(1) );   rotate( eh.od,[1 0 0],     prev_tor(2) );   rotate( eh.osMrkr,[1 0 0], prev_tor(1) );   rotate( eh.odMrkr,[1 0 0], prev_tor(2) );      %% XY plot setup    if plotXY      % load the settings from the XYplot axis' 'UserData'  They were stored      % there by the 'refresh_pr' or 'Done' commands in 'xyplotsettings.m'      % if you try to play w/o first initializing the xy settings, the xy init      % window will be called, and nothing can happen until it is dismissed.      xyv=wh.wf_axXY.UserData{1};      if ~iscell(xyv)         xyplotsettings('initialize')         uiwait         xyv=wh.wf_axXY.UserData{1};      end            l1_color  = whatcolor(xyv.line1color);      l1_style  = g.geStyles(xyv.line1style);      h1_color  = whatcolor(xyv.head1color);      h1_symbol = g.geSymbol(xyv.head1symbol);            % If second word of x_data_str is 'other', the user selected data directly      % from the workspace, and should not be modified, just placed in 'xtemp'.      % Otherwise, use 'eval' to place the actual data into 'xtemp', which will      % be differentiated as needed, and the subarray as selected by the 'start'      % and 'stop' controls will be placed into 'XData' for playback.      % The 's' appended to 'x_chan' turns e.g. 'lh' into 'lhs', which is the      % scaled and offset version of 'lh'. (Don't do this for 'other' data.)      % Ditto for 'YData'.      [x_chan, temp]=strtok(xyv.x_dat_str,','); x_deriv=temp(2:end);      if strcmpi(x_deriv,'other')         % have to pull the same fugly trick as we did in 'xyplotsettings'         % (in the strfind(xybutton,'other') code) to create a temporary global         % variable, both here and in the base workspace, that will allow us to         % access the array specified in the 'other' control.         evalin('base','global ebtempresult')         evalin('base',['ebtempresult = ' x_chan ';'])         xtemp = ebtempresult;         clear global ebtempresult      else         xtemp=NaN;         eval(['xtemp = ' x_chan 's;'])         if x_deriv(1)=='v'            xtemp=d2pt(xtemp,2);         elseif x_deriv(1)=='a'            xtemp=d2pt(xtemp,2); xtemp=d2pt(xtemp,2);         end      end            [y_chan, temp] = strtok(xyv.y_dat_str,','); y_deriv=temp(2:end);      if strcmpi(y_deriv,'other')         evalin('base','global ebtempresult')         evalin('base',['ebtempresult = ' y_chan ';'])         ytemp = ebtempresult;         clear global ebtempresult      else         ytemp=NaN;         eval(['ytemp = ' y_chan 's;'])         if y_deriv(1)=='v'            ytemp=d2pt(ytemp,2);         elseif y_deriv(1)=='a'            ytemp=d2pt(ytemp,2); ytemp=d2pt(ytemp,2);         end      end            xyv.history = abs(str2double(xyv.history));      if xyv.samp_or_sec == 1                     % time         timeshift=round(xyv.history*samp_freq);      else                                        % samples         timeshift=round(xyv.history);      end      xdata = xtemp(startpt:stoppt);      ydata = ytemp(startpt:stoppt);            frontpad = NaN * ones(timeshift,1);      xyv.ppdata_x = [frontpad; xdata];      xyv.ppdata_y = [frontpad; ydata];            set(wh.wf_dataXY,'Color',l1_color.rgb,'LineStyle',l1_style)      set(wh.wf_dataXY,'XData',[],'YData',[])      set(wh.wf_overXY, 'Color',h1_color.rgb,'Marker',h1_symbol,...         'MarkerFaceColor',h1_color.rgb,'MarkerEdgeColor','w')      wh.wf_overXY.XData=[];      wh.wf_overXY.YData=[];            figure(wfig); hold on      wh.wf_axXY.UserData={xyv 1 xyh};   end         %% animation        t_betw_frames=playstep/samp_freq;   ii=startpt;      % This is the animation loop. it is inherently slow, thanks to the very   % time consuming call to 'drawnow.' I suspect that there is nothing that   % will ever improve its performance. Best time between frames, even with   % 'live monitor' off is ~0.075 seconds for large eyeballs.   % (measured on dual GHz G4, ML7.01 (R14,SP1), OS X 10.3.7)      %profile on   a=1; %p=0;   while ii<=stoppt      stoppt=round(ch.stop_sli.Value);  % can stop animation in the middle      tic;      eh.osSocket.View=[lhs(ii)+90 -lvs(ii)];      eh.odSocket.View=[rhs(ii)+90 -rvs(ii)];      if lts(ii)         rotate(eh.os,[1 0 0],     lts(ii)-prev_tor(1));         rotate(eh.osMrkr,[1 0 0], lts(ii)-prev_tor(1));      end      if rts(ii)         rotate(eh.od,[1 0 0],     rts(ii)-prev_tor(2));         rotate(eh.odMrkr,[1 0 0], rts(ii)-prev_tor(2));      end      prev_tor=[lts(ii) rts(ii)];            ch.cur_sli.Value=ii;      ch.cur_txt.String=num2str(ii);      ch.cur_txt2.String=num2str(ii/samp_freq,3);            % get the eyeball frame      if make_eb_movie         F=getframe(efig);         writeVideo(eb_mov,F);      end            % Update the waveform window. (frippery)      % Used to be a single call to 'ebAct3D('hvt_update')' but the recursive      % nature of that call adds a lot of extra overhead. Such is life.      ii=ch.cur_sli.Value;      if livemonitor         xval=ii/samp_freq;                  if plotHOR            wh.wf_overLH.XData=xval;            wh.wf_overLH.YData=lhs(ii);            wh.wf_overRH.XData=xval;            wh.wf_overRH.YData=rhs(ii);         end         if plotVRT            wh.wf_overLV.XData=xval;            wh.wf_overLV.YData=lvs(ii);            wh.wf_overRV.XData=xval;            wh.wf_overRV.YData=rvs(ii);         end         if plotTOR            wh.wf_overLT.XData=xval;            wh.wf_overLT.YData=lts(ii);            wh.wf_overRT.XData=xval;            wh.wf_overRT.YData=rts(ii);         end         if plotXY            % We have to tack some NaN data onto the beginning of the            % array (and shift it) so we can have some history to display.            ind=ii-startpt+1;            wh.wf_dataXY.XData=ppdata_x(ind:timeshift+ind);            wh.wf_dataXY.YData=ppdata_y(ind:timeshift+ind);            wh.wf_overXY.XData=ppdata_x(timeshift+ind);            wh.wf_overXY.YData=ppdata_y(timeshift+ind);         end      end      % get the waveform frame      if make_wf_movie         F=getframe(wfig);         writeVideo(wf_mov,F);      end            drawnow      %t1(a)=toc; a=a+1;      t1=toc; a=a+1;      %t1=toc;      time_to_pause=1000*(t_betw_frames-t1);  %in milliseconds      if time_to_pause>0         mypause(time_to_pause)         %p=p+1;      end      ii=ii+playstep;   end      % eyes front, mister! We are done with playback. reset eyes.   mypause(150)   eh.osSocket.View=[0+90 0];   eh.odSocket.View=[0+90 0];   eh.osSocket.UserData=0;   eh.odSocket.UserData=0;   rotate( eh.os,[1 0 0],     -prev_tor(1) );   rotate( eh.od,[1 0 0],     -prev_tor(2) );   rotate( eh.osMrkr,[1 0 0], -prev_tor(1) );   rotate( eh.odMrkr,[1 0 0], -prev_tor(2) );   drawnow      % clear the wform markers   if plotHOR, wh.wf_overLH.YData=NaN; wh.wf_overRH.YData=NaN; end   if plotVRT, wh.wf_overRV.YData=NaN; wh.wf_overLV.YData=NaN; end   if plotTOR, wh.wf_overRT.YData=NaN; wh.wf_overLT.YData=NaN; end      %%prev_tor=0; % unneeded for 'play'?      % playback is over   pbH.UserData=0;      % if user hit 'stop' button, the 'stop' slider is wrong. Fix it.   ch.stop_sli.Value=str2double(ch.stop_txt.String);      figure(cfig)         elseif strcmpi(buttName,'hvt_update')   %% hvt_update   ii=ch.cur_sli.Value;   if livemonitor      if plotHOR         wh.wf_overLH.XData=ii/samp_freq;         wh.wf_overLH.YData=lhs(ii);         wh.wf_overRH.XData=ii/samp_freq;         wh.wf_overRH.YData=rhs(ii);      end      if plotVRT         wh.wf_overLV.XData=ii/samp_freq;         wh.wf_overLV.YData=lvs(ii);         wh.wf_overRV.XData=ii/samp_freq;         wh.wf_overRV.YData=rvs(ii);      end      if plotTOR         wh.wf_overLT.XData=ii/samp_freq;         wh.wf_overLT.YData=lts(ii);         wh.wf_overRT.XData=ii/samp_freq;         wh.wf_overRT.YData=rts(ii);      end      if plotXY         % we had to tack some NaN data onto the beginning of the         % array (and shift it) so we can have some history to display.         xyv=wh.wf_axXY.UserData{1};         %xyh=wh.wf_axXY.UserData{3};                  if ~xyv.played_yet, return; end         if length(xyv.ppdata_x)<2, return; end                  xyv.history = abs(str2double(xyv.history));         if xyv.samp_or_sec==1                       % time            timeshift=round(xyv.history*samp_freq);         else                                     % samples            timeshift=round(xyv.history);         end         ind=ii-startpt+1;         wh.wf_dataXY.XData=xyv.ppdata_x(ind:timeshift+ind);         wh.wf_dataXY.YData=xyv.ppdata_y(ind:timeshift+ind);         wh.wf_overXY.XData=xyv.ppdata_x(timeshift+ind);         wh.wf_overXY.YData=xyv.ppdata_y(timeshift+ind);      end   end      elseif strcmpi(buttName,'crosshairs')   ch.crossHstate = ch.crossH.Value;   if ch.crossHstate==0, newVis='off'; else, newVis='on'; end   chLineH = ch.crossH.UserData;   chLineH(1).Visible=newVis;   chLineH(2).Visible=newVis;   chLineH(3).Visible=newVis;   chLineH(4).Visible=newVis;      elseif strcmpi(buttName,'tormrkr')   val = go.Value;   if val      eh.osMrkr.Visible='on';      eh.odMrkr.Visible='on';      %set(eh.osMrkr,'MarkerEdgeColor',[1 0 0]);      %set(eh.osMrkr,'MarkerFaceColor',[1 0 0]);      %set(eh.odMrkr,'MarkerEdgeColor',[1 0 0]);      %set(eh.odMrkr,'MarkerFaceColor',[1 0 0]);   else      eh.osMrkr.Visible='off';      eh.odMrkr.Visible='off';      %set(eh.odMrkr,'MarkerEdgeColor','None');      %set(eh.osMrkr,'MarkerEdgeColor','None');      %set(eh.odMrkr,'MarkerFaceColor','None');      %set(eh.osMrkr,'MarkerFaceColor','None');   end      elseif strcmpi(buttName,'wf_draw')   %% 'wf_draw'   if ishandle(go)      caller=go.UserData;   else      caller='cfig';   end                  % Why was 'wf_draw' called? (could be 'plot h/v/t/pp' checkbox   % or could be result of data scaling. If it is checkbox call   % make sure that at least one checkbox remains checked.   value = ch.plotVRTh.Value || ch.plotHORh.Value || ...      ch.plotTORh.Value || ch.plotXYh.Value;      if ~value          % if user is turning off final checkbox      go.Value=1;     % you can't do that!      return   end      axBGcolr=[1 1 1];   figBGcolr = [0.94 0.94 0.94];   ch_color{1,1}=pr.rhColor;   ch_color{1,2}=pr.lhColor;   ch_color{2,1}=pr.rvColor;   ch_color{2,2}=pr.lvColor;   ch_color{3,1}=pr.rtColor;   ch_color{3,2}=pr.ltColor;      % get the window position. we only care about the origin.   figure(wfig);   wfigpos=wfig.Position;      % if there is pre-existing user data in the XY plot axis, retain it.   % we will restore it at the end of this section   % is this necessary? 'datscale' stores offset/scale values in the   % H,V,T (L&R) axes user data. but do we want to save it?  hmmmm.   wh=wfig.UserData{2};      xy_ax_userD = cell(2,1);   if isfield(wh,'wh.wf_axXY')      if ishandle(wh.wf_axXY)         xy_ax_userD=wh.wf_axXY.UserData;      end   end   clf      % num_ax, numplanes were calculated at the beginning of ebAct3D   if numplanes==1      wfigmax=[300 280];          %% 255   elseif numplanes==2      wfigmax=[300 540];          %% 507   elseif numplanes==3      wfigmax=[300 670];          %% 640   elseif numplanes==4      wfigmax=[300 810];          %% 780   else      return   end      % since wfig window can be resized, we want to use its CENTER   % (which is saved as 'wf_center' and was used in eb3d to set wfig pos)   % Then we need to calculate new x,y origins based on wfig's center and scale   wf_size = ch.wf_size_sli.Value;   maxwidth=wfigmax(1); maxheight=wfigmax(2);   x0      = wfigpos(1);   y0      = wfigpos(2);   width   = wfigpos(3);   height  = wfigpos(4);   center  = [x0+width/2, y0+height/2];   new_wid = maxwidth*wf_size;   new_hgt = maxheight*wf_size;   new_x0  = center(1)-new_wid/2;   new_y0  = center(2)-new_hgt/2;      wfig.Position=[new_x0, new_y0, new_wid, new_hgt];   wfig.Color=figBGcolr;      ax_units = 'Normalized';   % 'yorig' is y origin for each axis   % majick numbers -- determined by trial and error.   yorig{7} = [0.875 0.765 0.625 0.515 0.375 0.265 0.045];   yorig{6} = [0.85 0.71 0.525 0.385 0.20 0.06];   yorig{5} = [0.83 0.68 0.48 0.33 0.055];   yorig{4} = [0.77 0.56 0.29 0.08];   yorig{3} = [0.74 0.49 0.07];   yorig{2} = [0.53 0.13];   yorig{1} =  0.15;      % 'ht' is height of each axis; 'ppht' is the height of the pp axis   % majick numbers -- determined by trial and error.   ht{7} = 0.09;  ppht{7} = 0.15;   ht{6} = 0.11;   ht{5} = 0.13;  ppht{5} = 0.185;   ht{4} = 0.18;   ht{3} = 0.20;  ppht{3} = 0.30;   ht{2} = 0.35;   ppht{1} = 0.75;      xorig=0.18; wid=0.74;      plotSTM=ch.plotSTMh.Value;      % start drawing the desired axes in the wf window.   sub_p=1; %wh.wf_ax=gobjects(3,2);    wf_over=gobjects(3,2);      chanstr   = {'rhs', 'lhs'; 'rvs', 'lvs'; 'rts', 'lts'};   titlestr  = {'Horizontal'; 'Vertical'; 'Torsional'};   ylabelstr = {['RH (' degstr ')'],['LH (' degstr ')'];...      ['RV (' degstr ')'],['LV (' degstr ')'];...      ['RT (' degstr ')'],['LT (' degstr ')'] };      minval = [minRHS minLHS; minRVS minLVS; minRTS minLTS];   maxval = [maxRHS maxLHS; maxRVS maxLVS; maxRTS maxLTS];   scale  = [rh_scale  lh_scale;  rv_scale  lv_scale;  rt_scale  lt_scale];   offset = [rh_offset lh_offset; rv_offset lv_offset; rt_offset lt_offset];      if wf_size>0.85      titleFSize=14; xyFSize=12;   elseif wf_size>0.7      titleFSize=12; xyFSize=10;   elseif wf_size>0.6      titleFSize=10; xyFSize=8;   elseif wf_size>=0.5      titleFSize=8; xyFSize=6;   end      plotAX(1)=plotHOR; plotAX(2)=plotVRT; plotAX(3)=plotTOR;   wh.linH=gobjects(4,2);   stim{1}=st; stim{2}=sv;   st_color=pr.stColor;   sv_color=pr.svColor;         for x=1:3      if plotAX(x)         %re         wh.wf_ax(x,1) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);         hold on; box on; axis tight; grid;         if plotSTM && x<3            wh.linH(4,1)=line(t,stim{x},'Color',st_color);         end         a=eval(chanstr{x,1});         wh.linH(x,1)=line(t,a,'Color',ch_color{x,1});         title(titlestr{x},'FontSize',titleFSize)         ylabel(ylabelstr{x,1},'FontSize',xyFSize)         wf_over(x,1) = plot(NaN, NaN,'wo');         set(wf_over(x,1),'MarkerSize',6,'MarkerFaceColor','r')         if minval(x,1)~=maxval(x,1)            wh.wf_ax(x,1).YLim=[minval(x,1) maxval(x,1)];         end         %set(wh.wf_ax(x,1),'UserData',{scale(x,1), offset(x,1) });         wh.wf_ax(x,1).XLim=[startpt/samp_freq stoppt/samp_freq];         wh.wf_ax(x,1).XTickLabel='';         wh.wf_ax(x,1).Units=ax_units;         wh.wf_ax(x,1).Color=axBGcolr;         sub_p=sub_p+1;         %le         wh.wf_ax(x,2) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);         hold on; box on; axis tight; grid;         if plotSTM && x<3            wh.linH(x,1)=line(t,stim{x},'Color',sv_color);         end         a=eval(chanstr{x,2});         wh.linH(x,2)=line(t,a,'Color',ch_color{x,2});         ylabel(ylabelstr{x,2},'FontSize',xyFSize)         wf_over(x,2) = plot(NaN, NaN,'wo');         set(wf_over(x,2),'MarkerSize',6,'MarkerFaceColor','r')         if minval(x,2)~=maxval(x,2)            wh.wf_ax(x,2).YLim=[minval(x,2) maxval(x,2)];         end         %set(wh.wf_ax(x,2),'UserData',{scale(x,2), offset(x,2) });         wh.wf_ax(x,2).XLim=[startpt/samp_freq stoppt/samp_freq];         wh.wf_ax(x,2).Units=ax_units;         wh.wf_ax(x,2).Color=axBGcolr;         sub_p=sub_p+1;      end   end      try wh.wf_axRH=wh.wf_ax(1,1); catch; end   try wh.wf_axRV=wh.wf_ax(2,1); catch; end   try wh.wf_axRT=wh.wf_ax(3,1); catch; end      try wh.wf_axLH=wh.wf_ax(1,2); catch; end   try wh.wf_axLV=wh.wf_ax(2,2); catch; end   try wh.wf_axLT=wh.wf_ax(3,2); catch; end      try wh.wf_overRH=wf_over(1,1); catch; end   try wh.wf_overRV=wf_over(2,1); catch; end   try wh.wf_overRT=wf_over(3,1); catch; end      try wh.wf_overLH=wf_over(1,2); catch; end   try wh.wf_overLV=wf_over(2,2); catch; end   try wh.wf_overLT=wf_over(3,2); catch; end      % add the xlabel to the final (non XY) axis   if num_ax>1,xlabel('Time (seconds)','FontSize',xyFSize); end      % draw the XY axis   wh.wf_axXY=gobjects; wh.wf_dataXY=gobjects; wh.wf_overXY=gobjects;   if plotXY      % create axis w/appropriate labels      % create empty plot for ppl data to be drawn into      wh.wf_axXY = axes('Position',[xorig yorig{num_ax}(sub_p) wid ppht{num_ax}]);      box; hold on      wh.wf_dataXY = plot(NaN, NaN, 'g');      wh.wf_overXY = plot(NaN, NaN, 'wo');      set(wh.wf_overXY,'MarkerSize',6,'MarkerFaceColor','r')      title('XY plot','FontSize',titleFSize)      xlabel('X units','FontSize',xyFSize)      ylabel('Y units','FontSize',xyFSize)      wh.wf_axXY.Units=ax_units;      wh.wf_axXY.Color=axBGcolr;      wh.wf_axXY.UserData={0,0,0}; % xyv, 0, xyh   end      wfig.UserData={planes,wh,{offset scale},1};   %% 1: wh.wf_ax_inited      % does updated wf window still have XY plot axis? If so, restore old user data.   if ishandle(wh.wf_axXY)      if ~isempty(xy_ax_userD)         wh.wf_axXY.UserData=xy_ax_userD;      end   end      % if called from 'datscale' make the scaling window the foremost one.   % otherwise bring the controls window to the front   if strcmpi(caller,'ds')      figure(sfig)   else      figure(cfig)   end   %%% end wf_draw %%%   elseif strcmpi(buttName,'load_data')   %% load_data   % button already called 'ebdataload' which simply contains the name of   % preferred method to load data (first clearing out the previous data).   % Now we verify that it is valid data. Then must update settings of   % various controls to reflect the properties of the new data.         if ischar(go),keyboard;end   em_data=select_emdata(go);   if isempty(em_data), return; end   if isstruct(em_data) && isfield(em_data,'data')      em_data=em_data.data;   else      return   end      [status,datlen,noHOR,noVRT,noTOR,noSTM]=ebdatacheck(em_data);   if status==0, return; end      %ch.availDataH.UserData=em_data; %already set in select_emdata      if noHOR      ch.plotHORh.Enable='off';      ch.plotHORh.Value=0;   else      ch.plotHORh.Enable='on';   end      if noVRT      ch.plotVRTh.Enable='off';      ch.plotVRTh.Value=0;   else      ch.plotVRTh.Enable='on';   end      if noTOR      ch.plotTORh.Enable='off';      ch.plotTORh.Value=0;   else      ch.plotTORh.Enable='on';   end      if noSTM      %ch.plotTORh.Enable='off'; ch.plotTORh.Value=0;   else      %ch.plotTORh.Enable='on';   end      ch.start_sli.Max=datlen;   ch.cur_sli.Max=datlen;   ch.stop_sli.Max=datlen;   ch.stop_sli.Value=datlen;   ch.stop_txt.String=num2str(datlen);   ch.stop_txt2.String=num2str(datlen/samp_freq,3);   cfig.UserData=ch;   ebAct3D('wf_draw')   %%%wh=wfig.UserData{2};      elseif strcmpi(buttName,'setprefs')   %create a settings window   pr=eb3dprefs('initialize');   ch.eb3dPrefsBH.UserData=pr;      elseif strcmpi(buttName,'done!')   cur_dir=pwd;   cd(findomprefs)   efigpos = efig.Position;   cfigpos = cfig.Position;   wfigpos = wfig.Position;   wf_size = ch.wf_size_sli.Value;   eb_size = ch.eb_size_sli.Value;   eyeColor = eh.od.UserData;   wf_center = [ wfigpos(1)+wfigpos(3)/2, wfigpos(2)+wfigpos(4)/2 ];      % get the latest movie making preferences   pr=ch.eb3dPrefsBH.UserData;      save ebPrefs.mat eyeColor efigpos cfigpos wfigpos wf_center ...      pr eb_size wf_size eyeliner eyelight btxtstr      cd(pathsafe(cur_dir))   %uiresume      try delete(efig), catch; end   try delete(cfig), catch; end   try delete(wfig), catch; end   try delete(pfig), catch; end   try delete(sfig), catch; end   try delete(xyfig), catch; end   returnend  % if strcmpi(buttName ...% update e & c figures' UserData (wh is updated in wf_draw & change_bg)efig.UserData=eh;cfig.UserData=ch;end %function ebAct3D%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% mypause.m: a true pause function for delays under a second% Usage: mypause(delay)% where delay is the desired time in milliseconds% NOTE: accuracy is generally good within about 5 ms% Written by:  Jonathan Jacobs%              October 1999  (last mod: 10/19/99)function mypause(delay)diff=0;tic;while diff*1000 < (delay-0.25)   diff=toc;endend %function mypause