% hv2r.m: create a vector 'r' that is the pythagorean combination of% the horizontal and vertical components of the eye movement.% Both position and velocity data are created. Magnitude AND direction% are properly preserved.%% *** For reasonable results, hv2r should be invoked only on data that has    ***% *** already been shifted so that the foveations (Hor AND Vert) are at zero. *** %% Usage: r = hv2r(hor, vrt, mode, display);  %% the 'mode' and 'display' arguments are optional%   mode:    'h': use horizontal sign to determine output vector's sign%		     'v': use vertical sign to determine output vector's sign%		     'c': (default) use the clever algorithm to determine output vector's sign.%	display:  0: (default) do not create a figure showing the result%             1: create a figure with the horizontal, vertical and result vector data.%% Written by:  Jonathan Jacobs%              July 2002 - April 2007 (last mod: 04/17/07)function r = hv2r(hor, vrt, mode, disp)global samp_freqif nargin==0, help hv2r; return; endif nargin<3, mode = 'c'; disp=0; endif nargin<4, disp=0; end[hr,hc] = size(hor);  [vr,vc] = size(vrt);% make sure data is ordered in a columnif hr<hc, hor=hor'; endif vr<vc, vrt=vrt'; endh_vel = d2pt(hor, 4, samp_freq);v_vel = d2pt(vrt, 4, samp_freq);%%%%%%%%%%%%%%%%%%%%%%%%%%%%% if we shift the h & v data so that all the points are positive, can we% avoid some of the worst issues of obvious waveform distortion?  This is% only a stopgap solution however, since we really need to know the point% of foveation from momemt to moment to accurately calculate thetrue radial% distance from the fovea.%h_min = min(hor);  v_min = min(vrt);%h_shift = 1.0*h_min;   v_shift = 1.0*v_min;%if h_shift<0, hor = hor - h_shift; end%if v_shift<0, vrt = vrt - v_shift; end% the answer is no.  The shift simply distorts the waveform in a different % way, often leading to a radial waveform that is clearly wrong, in that it is% SMALLER in magnitude than one of the h,v components. UNPOSSIBLE!%% It looks like the best solution is still to "somehow" determine where the% center of the fovea really is at each moment.  sqrt( (x-x0)^2 + (y-y0)^2 )%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% How do we set the sign for points in the resulting vector waveform? % Simple approach: which ever plane is largest (hor vs vrt) takes it.% could also compare the squared values.% Possible downside: could switch from + to - from sample to sample if h,v% magnitudes are very close.  This would lead to ridiculous velocity trace% if it is derived from the radial position waveform.  Solution? Build the% radial velocity vector from h,v velocities, following the same +/- rules% we  use for the radial position.h_sgn = sign(hor);v_sgn = sign(vrt);hv_sum = hor + vrt;hv_sum_sgn = sign(hv_sum);% use the sign-preserving waveforms for determining final signhor_sqr = hor .* abs(hor);  % preserves signvrt_sqr = vrt .* abs(vrt);  % preserves sign % use the absolute waveforms for determining final magnitudehor_sqr_abs = abs(hor_sqr);  % does NOT preserve the sign -- all POSITIVEvrt_sqr_abs = abs(vrt_sqr);  % does NOT preserve the sign -- all POSITIVEhv_sqr_sum = hor_sqr_abs + vrt_sqr_abs;hv_sqr_sum_sgn = sign(hor_sqr + vrt_sqr);%hv_sqr_sum = hor_sqr + vrt_sqr;%hv_sqr_sum_sgn = sign(hv_sqr_sum);switch mode   case 'c'     hv_sgn = hv_sqr_sum_sgn;     %hv_sgn = hv_sum_sgn;   case 'h'     hv_sgn = h_sgn;   case 'v'     hv_sgn = v_sgn;   otherwise     disp('Error! No sign mode specified.')     returnendr = sqrt(abs(hv_sqr_sum)) .* hv_sgn;%%%%% do we actually need to do this?%%%%% not currently using the result.  but that could change...% now make the radial velocity vel_sum = h_vel + v_vel;vel_sum_sgn = sign(vel_sum);% use the sign-preserving waveforms for determining final signh_vel_sqr = h_vel .* abs(h_vel);  % preserves signv_vel_sqr = v_vel .* abs(v_vel);  % preserves sign % use the absolute waveforms for determining final magnitudeh_vel_sqr_abs = abs(h_vel_sqr);  % does NOT preserve the signv_vel_sqr_abs = abs(v_vel_sqr);  % does NOT preserve the sign vel_sqr_sum = abs(h_vel_sqr) + abs(v_vel_sqr);vel_sqr_sum_sgn = sign(h_vel_sqr + v_vel_sqr);%vel_sqr_sum = h_vel_sqr + v_vel_sqr;%vel_sqr_sum_sgn = sign(vel_sqr_sum);if(0)   vel_sgn = vel_sqr_sum_sgn; else   vel_sgn = vel_sum_sgn;endr_vel = sqrt(abs(vel_sqr_sum)) .* vel_sgn;% display the resultsif (disp)	t=maket(hor);   if disp == 3		figure		subplot(3,1,1); plot(t, hor); ylabel('Hor. Position (¡)')		subplot(3,1,2); plot(t, vrt); ylabel('Vert. Position (¡)')		subplot(3,1,3); plot(t, r); ylabel('Radial Position (¡)')		xlabel('Time (seconds)')			figure		subplot(3,1,1); plot(t, h_vel); ylabel('Hor. Velocity (¡/s)')		subplot(3,1,2); plot(t, v_vel); ylabel('Vert. Velocity (¡/s)')		subplot(3,1,3); plot(t, r_vel); ylabel('Radial Velocity (¡/s)')		xlabel('Time (seconds)')     else      figure      plot(t,hor,'c',t,vrt,'b',t,r,'r'); ept      figure      plot(t,h_vel,'c',t,v_vel,'b',t,r_vel,'r'); evt  endend