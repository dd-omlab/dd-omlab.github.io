% refix.m:  use when the subject fixated on targets other than just at zero degrees.% Refix will read in a control file and subtract the appropriate offsets from the % last data record loaded.%% written by: Jonathan Jacobs%             December 1995 - December 2009 (last mod: 12/14/09)% load the control file.  it is the name of the selected file, with the% file extension ("dat", "txt", "obr", "lab" or whatever) replaced by a "z"function refix(filename)global samp_freq %rh lh rv lv rt lt shortname = upper(filename( 1:find(filename=='.')-1));zeroNormFile = [ shortname '.Z' ];disp( ['Searching ' zeroNormFile ' for re-zeroing corrections. '] )%disp( ['Reading ' zeroNormFile] )isFile = eval( ['exist(''' zeroNormFile ''')'] );  % == exist('xxxx.z')if (~isFile)   disp( [sprintf('\b') ' ** None found **'])   %disp( ['  <<It must be in the same directory as ' filename '>>'] )   clear isFile zeroNormFile   returnend[comp, ~] = computer;if strcmp( comp, 'MAC2' )   fid = fopen(zeroNormFile, 'r', 'l');   % little-endian else   fid = fopen(zeroNormFile, 'r');        % big-endianendrefix_text = fread(fid,'char');refix_text = refix_text';fclose(fid);% check to see if it's an old-style refix list filetemp = refix_text;emptyLine = 1;while( emptyLine ) 	[topline, temp, emptyLine, ~] = getnextl(temp);end[~, numWords] = procline(topline);if numWords == 2   clear temp	refix_old	return	%disp('You should never see this line.  Yikes!')endisEOF = 0; count = 0;while( ~isEOF )   % these five lines will read in the next non-empty line.   % if we are at the end of the file we return.  (Could put   % a message in the 'if isEOF' structure, if we wanted.   emptyLine = 1;   while( emptyLine )       [topline, refix_text, emptyLine, isEOF] = getnextl(refix_text);      if isEOF      	disp(['   Applied ' num2str(count) ' refixations.'])      	return      end    %disp('EOF reached')   end   [words, numWords] = procline(topline);   if ~(numWords == 4 || numWords == 5)   	disp(topline)   	error('Improperly formatted line in refix file.');   end    	chan = deblank(words(1,:)); 	eval( ['datalen = length(' chan ');'] )  	startPt = str2double(words(2,:)); 	stopPt = words(3,:);    stopPtFlag = 0; 	if strcmp(deblank(stopPt), 'end') 		stopPtFlag = 1; 		stopPt = datalen; 	  else 	   stopPt = str2double(words(3,:)); 	end    	 	shift = str2double(words(4,:)); 	 	validunits = 0; 	if numWords == 5 		units = lower(deblank(words(5,:))); 		if (strcmp(units,'time') || strcmp(units, 'samples')) 			validunits = 1; 		end 	end		if ~validunits		% units (time or samples) is determined by several factors. 		%	time: values that are either non-integer or'small' -- i.e. under a couple hundred 		%  sample: values are strictly integer and 'large'		if ( (startPt==fix(startPt) && stopPt==fix(stopPt)) && (stopPt-startPt>samp_freq/5) )			units = 'samples';		 else			units = 'time';		end 	 		 	 	endif strcmp(units, 'time')		startPt = startPt*samp_freq;		if startPt == 0, startPt = 1; end		if stopPtFlag			stopPt = datalen;		  else 			stopPt  = stopPt*samp_freq;		end	 elseif strcmp(units,'samples')         	 else	   error('Panic!  Timebase units unknown!  Must be ''samples'' or ''time''.')	end		% time to do the actual refixation work	% call 'refix_seg' with appropriate channel of data to be modified	eval([chan ' = refix_seg(' chan ', startPt, stopPt, shift);'])	count = count + 1;end %% while( ~isEOF )