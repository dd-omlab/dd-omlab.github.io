% vrgcal_get.m: Read in the vergence adjustments from the emData's % associated '_vrgbias.txt' file.% written by: Jonathan Jacobs% created   : 22 Nov 2020% % 23 Nov 2020: 1st test releasefunction vb = vrgcal_get(adj_fname,filename) %,samp_freq,verbose)%adjbias_err_flag = 1;%if nargin<4, verbose=0; end%samp_freq = 0;doScaling = 1; %enviroG(3);fprintf('Loading vergence adjustments from "%s"\n',adj_fname);if ~doScaling   disp('*** Scaling will NOT be applied ***')end% 'adj_fname' was determined in getbias.m.pn=fileparts(filename);fid = fopen(fullfile(pn,adj_fname),'r');adjbiastext = fread(fid);adjbiastext = char(adjbiastext');fclose(fid);% Find the filename we are looking for in the adjbias file[~,fn]=fileparts(filename);whereIsIt = strfind(lower(adjbiastext), deblank(lower(fn)));if isempty(whereIsIt)   fprintf('  I could not find this file in my list.\n' );   fprintf('  Open the vergence bias file "%s" and make sure that',adj_fname);   fprintf('  "%s" appears as one of the entries.\n',filename);   vb=[];   returnend% Get the text FOLLOWING the desired filenameadjbiastext = adjbiastext(whereIsIt:length(adjbiastext));[topline, adjbiastext, ~, ~] = getnextl(adjbiastext);[wordlist,numwords] = proclinec(topline);%organization = '';chan_count = str2double( wordlist{2} );%rectype    = lower( wordlist{3} );fileformat = lower( wordlist{4} );% Make sure that the adjbias file has the same number% of channels as we found when we read in the data file.% This test is not valid for rawbin, so we cheat.if strcmpi(fileformat,'rawbin') ||  strcmpi(fileformat,'binary')   dat_cols = chan_count;   %dat_len = numsamps/chan_count;endif exist('dat_cols','var')   if chan_count ~= dat_cols      disp(['Panic! The number of channels listed in bias file (' num2str(chan_count) ')' ])      disp(['does not match the number of channels read from the data (' num2str(dat_cols) ')!'])      disp('Aborting RD.')      return   endendswitch (fileformat)   case {'rawbin','ascii','asyst','binary'}      if numwords >= 5         %samp_freq = str2double(wordlist{5});         %samp_flag = 1;         %disp( ['  Sampling frequency: ' num2str(samp_freq)] );         %disp( ['  Duration of record: ' num2str(dat_len/samp_freq) ' seconds'] );         %vrgbiasvals.samp_freq = samp_freq;      end      if numwords >= 6         %organization = lower( wordlist{6} );      endend%vc = struct('chName','--','vdists',NaN,'vzeros',NaN);for ii = 1:chan_count   %robflag = 0;   % ignore comment lines   goodline = 0;   while ~goodline      [topline, adjbiastext, ~, ~] = getnextl(adjbiastext);      temp=stripcom(topline);      if ~isempty(temp), goodline=1; end   end   [wordlist,~] = proclinec(topline);   chName =  wordlist{1};   vb.(chName).chName = chName;   obrack=strfind(topline,'[');   cbrack=strfind(topline,']');   vb.(chName).vdists=str2num(topline(obrack(1):cbrack(1))); %#ok<*ST2NM>   vb.(chName).vzeros=str2num(topline(obrack(2):cbrack(2)));end   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %{switch rectype(1)      case {'c', 's'} % coil (or 'scleral')         z_adj(i) = str2double( wordlist{2} );         if verbose            disp( ['  Channel: ' chName{i} '       Offset: ' wordlist{2} ] )         end         max_adj(i,1) = 1;         min_adj(i,1) = 1;         if numwords == 3            max_adj(i,1) = str2double(wordlist{3});            if verbose               disp( ['                    Scale: ' wordlist{3} ] )            end         end         if numwords == 4            min_adj(i,1) = str2double(wordlist{4});            if verbose               disp( ['                    Scale: ' wordlist{4} ] )            end         end               case 'r' % robinson coil         if verbose            disp( ['  Channel: ' biases.chName{i} '     Offset: ' wordlist{2} ] )            disp( ['                  Scale: '  wordlist{3}] )            disp( ['                  Cal Pt: ' wordlist{4}] )         end         robflag = 1;         z_adj(i)      = str2double(wordlist{2});         maxcalpt(i,1) = str2double(wordlist{3});         max_adj(i,1)  = str2double(wordlist{4});         mincalpt(i,1) = str2double(wordlist{3});         min_adj(i,1)  = str2double(wordlist{4});               case {'i', 'v'}         % this applies to any method that needs asymmetric calibration         z_adj(i) = str2double(wordlist{2});         if verbose            disp( ['  Channel: ' chName{i} '     Offset: ' wordlist{2}] )         end         % how many calibration point pairs are there?         if numwords>5            % assuming equal number of leftward and rightward calibration pts.            % now that 'cal' has been modified, might not be valid assumption            % for time being, 'cal' will pad w/dummy entries if needed. (7/18/02)            numcalpts = fix((numwords-2)/4);            if numcalpts> maxnumcalpts, maxnumcalpts=numcalpts; end            for j = 1:numcalpts               maxcalptstr   = regexprep(wordlist{2+j},{'[',']'},' ');               maxcalpt(i,j) = str2double(maxcalptstr);               maxadjstr     = regexprep(wordlist{2+j+numcalpts},{'[',']'},' ');               max_adj(i,j)  = str2double(maxadjstr);               if verbose                  disp( ['    Cal pt: ' maxcalptstr  ', scale value: ' maxadjstr])               end               mincalptstr   = regexprep(wordlist{2+(2*numcalpts)+j},{'[',']'},' ');               mincalpt(i,j) = str2double(mincalptstr);               minadjstr     = regexprep(wordlist{2+(3*numcalpts)+j},{'[',']'},' ');               min_adj(i,j)  = str2double(minadjstr);               if verbose                  disp( ['    Cal pt: ' mincalptstr  ', scale value: ' minadjstr])               end            end         else            %numcalpts = 1;            %maxnumcalpts = 1;            maxadjstr    = wordlist{3};            max_adj(i,1) = str2double(maxadjstr);            maxcalpt(i,1) = 10;            minadjstr    = wordlist{4};            min_adj(i,1) = str2double(minadjstr);            mincalpt(i,1) = -10;            %disp( ['    Rightward scale value: ' maxadjstr])            %disp( ['    Leftward scale value: ' minadjstr])         end %%if numword   end  % switch rectype      % If this is an ASCII or binary file then we might need   % to read in the sampling freq (if it was not in the 'right' place.)   % (Retrieve, LabVIEW & Ober2 files store this info in their header.)   if ~samp_flag      switch lower(fileformat)         case {'ascii','asyst'}            sampfstr = wordlist(numwords,:);            samp_freq = str2double(sampfstr);            disp( ['  Sampling frequency: ' num2str(samp_freq)] );            %disp( ['  Duration of record: ' num2str(dat_len/samp_freq) ' seconds'] );         case {'rawbin','binary'}            % Not needed, since no RAWBIN files were created            % using the 'wrong' bias file format.      end   end %~if samp_flag   end % for imaxcalpt = maxcalpt(1:chan_count,1:maxnumcalpts);mincalpt = mincalpt(1:chan_count,1:maxnumcalpts);max_adj = max_adj(1:chan_count,1:maxnumcalpts);min_adj = min_adj(1:chan_count,1:maxnumcalpts);z_adj = z_adj';         % make into (numcalpt cols) x (chan_count rows)%max_adj = max_adj;%min_adj = min_adj;%adjbias_err_flag = 0;% crufty hack time: if we want to disable scaling (i.e. 'doScaling')% has been disabled in 'enviro', simply make the adjust values 0 & 1if ~doScaling || robflag   z_adj   = zeros(size(z_adj));   max_adj = ones(size(max_adj));   min_adj = ones(size(min_adj));endadjbiasvals.samp_freq = samp_freq;adjbiasvals.chName = chName;adjbiasvals.rectype=rectype;adjbiasvals.organization=organization;adjbiasvals.z_adj = z_adj;adjbiasvals.max_adj = max_adj;adjbiasvals.min_adj = min_adj;adjbiasvals.maxcalpt = maxcalpt;adjbiasvals.mincalpt = mincalpt;return   %}