% add_col.m: called by rd_ascii and rd_rtrv to add a new column % of data to the existing data set.  Since there are no guarantees% about either the size or the existing data or the size of the new% data, "add_col" must be able to NaN-pad either data set.% Most of this code has been lifted from the original 'getfile.m'% written by:  Jonathan Jacobs%              October 1995 - May 1996  (last mod: 05/28/96)function inp_arr = add_col( inp_arr, new_dat, ~) % whatcol )padding = [];[dat_len, ~]     = size(new_dat);[max_len, inp_col]   = size(inp_arr);if max_len == 0, max_len = dat_len; end  % for the first file entered% if the current data is longer than the array length% we will have to pad the previous data to make it workif dat_len > max_len   if max_len > 0, disp( '  expanding array with NaNs' ); end   size_diff = dat_len - max_len;                        % padding NaNs are   inp_arr = [inp_arr' NaN*ones(size_diff, inp_col)']';  % added to all the   max_len = dat_len;                                    % pre-existing cols   padding = [];end% but if the current data is SHORTER than the array% length, then we must pad it to fit.if (dat_len < max_len)   disp( '  padding data with NaNs' );   size_diff = abs(dat_len - max_len);   padding = NaN * ones(size_diff, 1);   dat_len = max_len;end% all things being equal (either naturally or paddedly)% we can _finally_ add the new data column to the array.if dat_len == max_len     % let's just be sure...   [~, inp_cols] = size(inp_arr);   inp_cols = inp_cols + 1;   npts=length([new_dat' padding']);   %inp_arr(1:npts,whatcol) = [new_dat' padding']';   inp_arr(1:npts,inp_cols) = [new_dat' padding']';end