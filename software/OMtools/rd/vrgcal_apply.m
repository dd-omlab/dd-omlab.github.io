% vrgcal_apply.m: apply vrgbias file to vergence data. Plot the adjusted% data, draw line start/stop of each segment, label with its distance.%% The vergence-calibrated data are saved into the original emData% structure in each channel's 'pos_vcal' field.% Also create new a new base workspace var for emData_vcal with the adjusted% vcal data in the .pos field. Break out its basic data into the base workspace.% Written by: Jonathan Jacobs% Based on  : biasgen,edfbiasgen% Created   : 10 Nov 2020%% 23 Nov 2020: 1st test release% 02 Dec 2020: 2nd test% 19 Jan 2022: Added 'rp,'lp' to exclusion% 22 Jan 2022: Draw start/stop timings for each data segment recorded at each%              distance, adds text label of the distance.% 25 Jan 2022: Now properly created a COPY (not just a REFERENCE) to the loaded%              emData var in memory. Updates it to create the vrg-calibrated %              emdata.% 04 Feb 2022: Now applies multiplanar biases to all data segments, not just%              explicitly calibrated straight-ahead segments. NOTE: this is%              simply applying the same bias to off-center targets as to %              central ones. Probably accurate, but not explicitly proven.% gets stuff stored in, or writes to, vc_app's user data fields:%  .emdata    -- data selected in 'datstat'%  .all_segs  -- sections of data that need to be vrgbias adjusted%  .vb        -- vergence bias values%  .ml_res    -- results, etc. read from '_results.mat'%  .po_res    -- results, etc. read from '_poem_results.mat'function vrgcal_apply(vc_app)% Let's get colorful! (list of fancy colors and stuff)% These will be used to color the vergence-calibrated segments.g=grapconsts;ll_clr=g.rgb([g.BRIGHTSUN, g.VIVIDVIOLET, g.RED, g.CORNFLOWER, ...   g.SUSHI, g.MEDGRAY, g.BLACK]);% If Vergence Calibration GUI is open, get its handle.if ~exist('vc_app','var')   vcwin = findwind('Vergence Calibration');else   vcwin=vc_app.VrgCalUIFig;end% If GUI not open and valid, try to open it.if ~ishandle(vcwin)   %fprintf('"vrgcal" requires the "Vergence Calibration" app.\n');   %fprintf('I will attempt to open it for you. Hang on.\n');   fprintf('Opening "Vergence Cal" app...\n');   vrgcal_gui   returnend% Get emdata, vergence cal data, tgtpos info stored in vcwin.try   ud=vcwin.UserData;   if isempty(ud)      fprintf('vcwin.UserData is empty!\n');      return   endcatch   fprintf('Cannot find vcwin.UserData!\n');   returnend% Retrieve emdata from GUI UserData.try   emd=ud.emdata.data;   if isempty(emd)      fprintf('"emdata" from "Vergence Cal" app is empty.\n');      return   end   %samp_freq=emd.samp_freq;catch   fprintf('I could not find "emdata" stored in the "Vergence Cal" app.\n');   returnend% Make sure we have good '_results.mat' data.try   csdd=vcwin.UserData.curr_sel_DD;   [pn,fn]=fileparts(csdd.Tag);   pnfn=fullfile(pn,[csdd.Value '_results.mat']);   vrg_res=load(pnfn);catch   fprintf('I could not load _results file.\n');end% We need vergence bias values, and target segments to% perform vergence offsetting for each target distance.% IF vb is NOT saved in GUI, load from file.vbname=['vrgbias_' csdd.Value '.txt'];try   vb=ud.vb;catch   vb=[];   fprintf('"vb" not found in the "Vergence Cal" app.\n');endif isempty(vb)   try      fprintf('Loading vergence biases from file.\n');      vb=vrgcal_get(vbname,fullfile(pn,fn));   catch      fprintf('Could not load vergence biases from file.\n');      return   end   ud.vb=vb;end% IF all_segs is NOT saved in GUI, generate using getsegs.try   all_segs=ud.all_segs;catch   all_segs=[];   fprintf('No "all_segs" stored in the "Vergence Cal" app.\n');endtry   %   % Inelegant, brute-force implementation.   fprintf('Will try to store "all_segs" in the "Vergence Cal" app.\n');   v_upd=0;   if ~isfield(all_segs,'rh') || all(vb.rh.vdists==0)      temp = getsegs(vcwin,'rh');      if all([temp.rh.dist]~=0),v_upd=1;end      all_segs.rh=temp.rh;      tgtdists = [temp.rh.dist];   end   if ~isfield(all_segs,'lh') || all(vb.lh.vdists==0)      temp = getsegs(vcwin,'lh');      if all([temp.lh.dist]~=0),v_upd=1;end      all_segs.lh=temp.lh;      tgtdists = [temp.lh.dist];   end   if ~isfield(all_segs,'rv') || all(vb.rv.vdists==0)      temp = getsegs(vcwin,'rv');      if all([temp.rv.dist]~=0),v_upd=1;end      all_segs.rv=temp.rv;      tgtdists = [temp.rv.dist];   end   if ~isfield(all_segs,'lv') || all(vb.lv.vdists==0)      temp = getsegs(vcwin,'lv');      if all([temp.lv.dist]~=0),v_upd=1;end      all_segs.lv=temp.lv;      tgtdists = [temp.lv.dist];   end   ud.all_segs = all_segs;catch   fprintf('I could not store "all_segs" in the "Vergence Cal" app.\n');   keyboard   returnendvrg_res.all_segs=all_segs;  %%%% moved to above 'save'if v_upd==1   fprintf('vrgcal_apply: Updating "vrg_res" in %s\n',pnfn);   save(pnfn,'-struct','vrg_res')end% segments can be retrieved from '_poem_results.mat' (PlusOptix)try    ud.po_res.all_segs=all_segs;catch, end% or (preferably) from  '_results.mat'try    ud.ml_res.all_segs=all_segs;catch, end% Make a copy of original emData structure. Will update its pos with% vrgcal-adjusted data.%emd_vcal = emd;        % WRONG! creates a reference NOT a new var!!!emd_vcal = emcopy(emd); % RIGHT! creates a new, unique var[shortname,exten] = strtok(emd.filename,'.');if contains(shortname,'_vcal')   keyboardendemd_vcal.filename = [shortname '_vcal' exten];% We now should have vb AND all_segs.% Apply them to the data channelsfound=0;figure;channels = ud.emdata.channels;%% Channel loop.% Apply ONLY to 'rh,'rv',lh','lv'. Ignore all other channels.for ch=1:length(channels)   thisch=emd.(channels{ch});   if ~any(strcmpi(thisch.channel,{'rh','lh','rv','lv'})) % VERIFY IS BETTER      continue   end   try      pos = thisch.pos;      if ud.UseDeblinkCB.Value         pos = ao_deblink(pos);  % get rid of the worst artifacts         fprintf('vrgcal_apply: deblink\n');      end   catch      pos = [];   end   t=maket(pos);   % Find this channel in vb.   dch = thisch.channel;   if dch(1)=='l'      lclr='g';   elseif dch(1)=='r'      lclr='b';   else      lclr='k';   end   for xx=1:length(fields(vb))      try    vch=vb.(dch).chName;      catch, vch='null'; end      % Plot data for this channel      if strcmpi(vch,dch)         %ymin(ch) = min(pos) - 0.1*abs(min(pos));         %ymax(ch) = max(pos) + 0.1*abs(max(pos));         sp=subplot(2,2,ch);box;hold on;ept         plot(t,pos,lclr);             titstr=sprintf('Chan: %s',dch); % can use \n to make multiline titles!         title(sp,titstr)         found=1;         break      end   end      % Apply vrgbias for this channel   if found      if isempty(vb.(dch))         % no vrgbias to apply         fprintf('No vergence bias to apply.\n');         continue      else         % bias will be applied below      end   else      fprintf('Could not find %s in vb!\n',dch);      return   end      % Get and adjust segs for this channel   try    seg=all_segs.(dch);   catch, seg=[]; end   if ~isempty(seg)      numcaldists=length(seg);      vcalpos = pos;       % Target distances Loop. (will be same for all channels)      for dd=1:numcaldists         thisdist = seg(dd).dist;         possegs = NaN(size(pos));         % Apply the bias for all data at that dist, plot, draw intervals         prevdist = -1000; %impossible distance         % If this channel has no cal, this loop will be skipped.         for ss=2:length(seg(dd).startind)             % start/stop of each segment            seginds=seg(dd).startind(ss):seg(dd).stopind(ss);            % Adjust it            try    possegs(seginds)=pos(seginds)-vb.(dch).vzeros(dd);            catch, keyboard; end            % Store the shifted data in '.pos_vcal'            emd.(dch).pos_vcal=possegs;            % Update our copy of 'pos'            vcalpos(seginds)=possegs(seginds);            % Draw each shifted posseg a new fancy color!            ll=plot(t,possegs,'k:');            ll.Color=ll_clr{dd};            ga=gca;            % Draw lines for the start and stop times of the zero-degree segs            % of the different distances. Display the distance.            thisangle = seg(dd).angle(ss);            if thisangle == 0               % was previous label the same dist? If yes, no need to draw               % it again.               t1=seg(dd).start(ss);    % time in sec               temp=line([t1 t1], ga.YLim);               temp.Color=ll_clr{dd};               temp.LineStyle=':';               t2=seg(dd).stop(ss);               temp=line([t2 t2],ga.YLim);               temp.Color=ll_clr{dd};               temp.LineStyle='-.';               % Don't draw same text sequentially.               if thisdist ~= prevdist                  %temp=text((t1+t2)/2, ga.YLim(1)+2, num2str(tgtdists(dd)));                  temp=text(t1, ga.YLim(1)+2, num2str(tgtdists(dd)));                  temp.Color=ll_clr{dd};                  temp.FontSize=8;               end               prevdist=thisdist;            end         end %for ss         % This distance is now adjusted.      end %for dd      % This channel is now adjusted.      % Update emd_vcal channel position with adjusted data.      emd_vcal.(dch).pos = vcalpos;   end %if non-empty segend %for ch% All channels are adjusted.%% Finish up. % Prettify figure.emdname=strtok(emd.filename,'.');emdname_vcal=strtok(emd_vcal.filename,'.');sp=subplot(2,2,1);title(sp, [nameclean(emdname_vcal) '   ' sp.Title.String])% Rewrite emd back into base as emdname.assignin('base', emdname,emd)evstr=sprintf('emd_extract(''%s'');',emdname);evalin('base', evstr);% Write emd_vcal into base as emdname_vcal.assignin('base', emdname_vcal,emd_vcal)evstr=sprintf('emd_extract(''%s'');',emdname_vcal);evalin('base', evstr);end % function