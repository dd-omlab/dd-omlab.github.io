% PGcalc.m: Iteratively find the best(?) pulse amplitude to make a saccade.%% Usage: set up "pwtstbed" with the PG width function you wish to use.% Settings: PWtstbed:Double Pulse:Pulse 1 Mag: "goal" (w/o quotes)%           PWtstbed:Double Pulse:Pulse 1 Dur: "stoptime" (w/o quotes)%% Set up "testbed" with the plant you wish to use, e.g. "Plant & Delay"% (NO PG!!!, just plant and optionally a delay before the plant!!)% Settings: Testbed:Double Pulse:Pulse 1 Mag: "stimhgt" (w/o quotes)%           Testbed:Double Pulse:Pulse 1 Dur: "stimdur" (w/o quotes)%% "delay" is the value of the delay block (if one is used)% in the plant model in seconds.% Written by:  Jonathan Jacobs%              November 1997 - October 1998 (last mod:  10/23/98)extra = 0.03;  % run the sim xx ms beyond pulse end to reach eye pos. peak%pdelay = input('Enter the delay for the test plant (in seconds): ');pdelay = 0.001;method =1;if method == 0   disp('Eye position will be measured at termination of pulse')   % goalpct: eye should be what pct of goal value at the end of the pulse?   goalpct = input('Eye should be at what fraction of target value? '); else   disp('Eye position will be measured at its peak value')   goalpct = 1;enddisp(' ')tic;disp(['  goal   eyepos    peak    tpeak  PW  diff     PH     iter   %error'])disp(['  -----------------------------------------------------------------'])iterLim = 200;   % How many times will we try before raising the error limit.index=0;pcterror=[]; errlist=[]; finalstim=[];stimdurlist=[]; stimlist=[];ss=[]; eyepos=[]; pts=[]; peak=[];whenpeak=[];%% use these two lines (one at a time) to create the data to put into%% "PHfnxxx" type functions.  (Use PHprint to format it nicely.)stimlist = [0.05:0.01:0.09];%stimlist = [(0.1:0.1:50.0)];%% Use this line to get a rougher overview%stimlist = [(0.05), (0.1:0.1:0.9), (1:50)];%% whatever...%stimlist = [(0.05),(.1:.1:2), (3:4), (5:5:50)];%stimlist = [(10.1:0.1:12.5)];%stimlist = [(0.1:0.1:1.0)];for goal = stimlist   index=index+1;   % find the pulse width   stoptime=0.25; % run 'pwtstbed' this long (seconds)   [a,b,c]=rk45('pwtstbed', stoptime, [], [1e-3, 0.001, 0.001, 0,0,2]);   pts = find(pwout==0);   stimdur = twClock(pts(2)-1) - twClock(pts(1));   stimdurlist(index) = stimdur;   stoptime = stimdur + extra + pdelay;  % run 'testbed' this long (seconds)   %plot(t,pwout)   %pause   % define starting points for the iterations   if index > 1      startpt = (stimlist(index)/stimlist(index-1)) *finalstim(index-1);    else      startpt = 45*goal;   end   stimhgt = startpt;   count=0;   error = 100;    fiddle = 2.0;    starterrlim = min(0.005*goal,0.05);   errlim = starterrlim;   resets = 0;   goal=goalpct*goal;   while (abs(error)>errlim) & (count<iterLim);      count=count+1;      [a,b,c]=rk45('testbed', stoptime, [], [1e-3, 0.001, 0.001, 0,0,2]);      % the $64K question: where/when do we meausure the eye's position      % to decide when it has reached the goal?  It would be much easier      % for a 2P-1Z plant, but for a 2P plant, it's a bit trickier since      % the plant dynamics are that much slower.      if method==0         eyepos(index) = out((stimdur*1000)+1); % at end of pulse?        else         eyepos(index) = max(out); % eye's peak pos (occurs _after_ pulse)      end            peak(index) = max(out);      temp = find(out==max(out));      whenpeak(index) = temp(1);      delaytopeak(index) = whenpeak(index)-(stimdur*1000);      ss(index) = NaN;      %ss(index) = out(length(out));      error = (eyepos(index) - goal);      errlist(count,index) = error;      pcterror(index) = error/goal;      stimhgt = stimhgt - error*fiddle;      finalstim(index) = stimhgt;      % If we've made it to the end of 'iterLim' trials without having found      % a good solution, there's the possibility that we can't get that      % close.  Perhaps we're oscillating, so let's try with a larger limit.      % In these cases we will probably end up searching for the best solution      % manually, but maybe we'll get lucky here, first...      if (count == iterLim-1)         %elist2 = errlist(:,index);         %elist3 = elist2(find(elist2 ~= 0));          %minerror = min(abs(elist3));         %errlim = 1.1*minerror;         count = 1;         resets = resets + 1;         if resets > 0  %3            errlim = errlim*1.5;              resets = 0;                  end         disp([' *****  New errlim: ' num2str(errlim) '  *****'])         %screwed this next line up when we reset 'resets'         %priorerrlists(:,resets) = errlist(:,index);       end   end      s = sprintf('%6.2f %8.4f %8.4f %5.0f %5.0f %4.0f %9.4f %6.0f %8.4f',...          stimlist(index), eyepos(index), peak(index),...          whenpeak(index), stimdurlist(index)*1000, delaytopeak(index),...          finalstim(index), count, pcterror(index)*100  );   disp(s) %  disp( [stimlist(index), eyepos(index), peak(index),... %         whenpeak(index), stimdurlist(index)*1000,... %         finalstim(index), count, pcterror(index)*100] )enddisp(['Elapsed time: ' num2str(toc)])figuresubplot(2,1,1)plot(stimlist,finalstim)xlabel('Saccade Magnitude')ylabel('Stimulus Amplitude')subplot(2,1,2)plot(stimlist,stimdurlist*1000)xlabel('Saccade Magnitude')ylabel('Stimulus Duration')