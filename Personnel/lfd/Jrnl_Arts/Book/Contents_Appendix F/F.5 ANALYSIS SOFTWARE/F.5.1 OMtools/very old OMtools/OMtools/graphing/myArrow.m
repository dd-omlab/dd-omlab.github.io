% myArrow.m:  a painfully simple routine to draw arrows.% Usage: myArrow(startPt, stopPt, headLen, headWidFactor)% where: startPt and stopPt are [x y] vectors%        headLen is the length of the arrowhead in pixels%        headWidFactor is between 0 and 1 (0.5 is default)% written by:  Jonathan Jacobs%              January 1998  (last mod: 01/08/98)function arrowH = myarrow(startPt, stopPt, headLen, headWidF,arrowColor)if nargin == 0   help myarrow   returnendif nargin < 5   arrowColor = 'r';endif nargin < 4   headWidF = 0.5;endif nargin < 3   headLen = 18;   headWidF = 0.5;endheadWidF = abs(headWidF);if (headWidF>1) | (headWidF<0)   headWidF = 0.5;end% how many pixels?oldunits=get(gca,'units');set(gca,'units','pixels');axPos = get(gca,'Pos');set(gca,'units',oldunits);deltaX = stopPt(1)-startPt(1);  % in data unitsdeltaY = stopPt(2)-startPt(2);  % in data units%linH = line([startPt(1) stopPt(1)],[startPt(2) stopPt(2)]);% convert from pixels to data-based measurexlims = get(gca,'XLim');ylims = get(gca,'YLim');xSize = xlims(2)-xlims(1); % in data unitsySize = ylims(2)-ylims(1); % in data unitsxSizePix = axPos(3) - axPos(1);  % in pixelsySizePix = axPos(4) - axPos(2);  % in pixelspixPerX = xSizePix/xSize;  % pixels/x-datapixPerY = ySizePix/ySize;  % pixels/y-datalineLenPixX = deltaX*pixPerX;                      % in pixelslineLenPixY = deltaY*pixPerY;                      % in pixelslineLenPix = sqrt(lineLenPixX^2 + lineLenPixY^2);  % in pixels% calc line angle.  gotta do it in pixelsif deltaX == 0,   lAngle = 90; elseif deltaY == 0;   lAngle = 0; else    lAngle = atan(lineLenPixY/lineLenPixX)*180/pi;endcAngle = 90-lAngle;% arrowhead is 18 pixels long.  how many data-based units?% arrowhead is 45 degahLen = headLen;ahAngle = 45;ahX = ahLen/pixPerX;                              % in data unitsahY = ahLen/pixPerY;                              % in data unitsahHalfBaseLen = ahLen*tan((ahAngle/2)*pi/180);    % in pixelsahHyp = sqrt(ahLen^2 + ahHalfBaseLen^2);          % in pixelsahBaseX = stopPt(1) - (ahLen/lineLenPix)*deltaX; %this is correctahBaseY = stopPt(2) - (ahLen/lineLenPix)*deltaY; %this is correctahBLX = (headWidF)*ahHalfBaseLen/pixPerX;   % in data unitsahBLY = (headWidF)*ahHalfBaseLen/pixPerY;   % in data unitsahVertX1 = ahBaseX + ahBLX*cos(abs(cAngle)*pi/180);ahVertY1 = ahBaseY - ahBLY*sin(abs(cAngle)*pi/180);ahVertX2 = ahBaseX - ahBLX*cos(abs(cAngle)*pi/180);ahVertY2 = ahBaseY + ahBLY*sin(abs(cAngle)*pi/180);%disp(' ')%disp(['X axis: ' num2str(pixPerX) ' pixels per x unit.'])%disp(['        ' num2str(ahX) ' x units equals ' num2str(ahLen) ' pixels.'])%disp(['Y axis: ' num2str(pixPerY) ' pixels per y unit.'])%disp(['        ' num2str(ahY) ' y units equals ' num2str(ahLen) ' pixels.'])% don't erase the current graphhold on% make sure that the axes are big enough for what is to follow.linH = line([startPt(1) startPt(2)], [stopPt(1) stopPt(2)]);% freeze the limits during for the drawingaxis(axis)delete(linH);arrowH = patch([startPt(1) ahBaseX ahVertX1 stopPt(1) ahVertX2 ahBaseX],...               [startPt(2) ahBaseY ahVertY1 stopPt(2) ahVertY2 ahBaseY],arrowColor);% black edge would obscure the arrow's stemset(arrowH,'EdgeColor',arrowColor);%plot([stopPt(1) ahBaseX],[stopPt(2) ahBaseY],'r')%plot([ahBaseX ahVertX1],[ahBaseY ahVertY1],'c')%plot([ahBaseX ahVertX2],[ahBaseY ahVertY2],'g')