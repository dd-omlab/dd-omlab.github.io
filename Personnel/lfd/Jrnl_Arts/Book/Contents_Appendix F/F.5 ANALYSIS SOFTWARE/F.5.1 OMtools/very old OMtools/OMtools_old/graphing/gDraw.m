% gDraw.m:  Called by 'draw.m' to draw a line or an arrow.% recognized commands: start, stop, down, move, up% recognized objects:  line, arrow, rectangle, circleS, circleT% Written by:  Jonathan Jacobs%              March 1997 - June 2000 (last mod: 06/25/00)function gDraw( action ) %%, objtype )global startYPt startXPt newXPt newYPtglobal finalXPt finalYPt linH drawMsgglobal xLimMode yLimMode objtypeglobal gdUnitHgf = findHotW;ga = get(gf,'CurrentAxes');if isempty(ga)   ga=gca;endaxClr = get(ga,'Color');if strcmp(axClr,'none')   figClr = get(gf,'Color');   if strcmp(figClr,'none')      tmpLinClr = [1 1 1];    elseif figClr == [0 0 0]      tmpLinClr = [1 1 1];    else      tmpLinClr = [0 0 0];   end elseif axClr == [0 0 0]   tmpLinClr = [1 1 1];else   tmpLinClr = [0 0 0];endif strcmp(get(gf,'Tag'), 'EditingWindow')   disp( 'gDraw: Bring a figure window to the front and try again.')   returnendpt = get(ga,'Currentpoint');if strcmp(action, 'start')   if (drawMsg)      disp([objtype ' drawing active.'])      disp('Type ''draw'' again to stop drawing.')   end   %xLimMode = get(ga,'XLimMode');	%yLimMode = get(ga,'YLimMode');	set(ga,'XLimMode','manual');	set(ga,'YLimMode','manual');	set(gf,'WindowButtonDownFcn', 'gDraw(''down'')');	set(gf,'WindowButtonMotionFcn', '');	set(gf,'WindowButtonUpFcn', 'gDraw(''up'')');	figure(gf) elseif strcmp(action, 'stop')   if (drawMsg)      disp(['Drawing stopped.'])   end   %set(ga,'XLimMode', xLimMode);   %set(ga,'YLimMode', yLimMode);   set(gf,'WindowButtonDownFcn', '');   set(gf,'WindowButtonMotionFcn', '');   set(gf,'WindowButtonUpFcn', '');   clear global xLimMode yLimMode   clear global startYPt startXPt newXPt newYPt   clear global finalXPt finalYPt linH    elseif strcmp(action, 'down')   %disp('down!')   set(gf,'WindowButtonMotionFcn', 'gDraw(''move'')');   set(gf,'Pointer','crosshair');   startXPt = pt(1,1);   startYPt = pt(1,2);   linH = line([NaN,NaN], [NaN, NaN]);   set(linH,'EraseMode', 'xor');   set(linH,'Color', tmpLinClr);   %if ~strcmp(lower(objtype),'line')      set(linH,'LineStyle', ':');   %end elseif strcmp(action, 'move')   %disp('move!')   newYPt = pt(1,2);   newXPt = pt(1,1);   set(linH,'XData', [startXPt, newXPt]);   set(linH,'YData', [startYPt, newYPt]); elseif strcmp(action, 'up')   % this is where we do most of the work.  When the mouse button   % is released we will delete the guide line (except when we are   % actually drawing a line) and then draw the object.   %disp('up!')   finalYPt = pt(1,2);   finalXPt = pt(1,1);   % check to see if the mouse moved between mouse down and mouse up   % if it didn't then we don't want to draw anything.   if (finalXPt == startXPt) & (finalYPt == startYPt)      delete(linH)    else  % draw something      % writing 'myArrow' was fun.  it was an interesting challenge.      if strcmp(lower(objtype), 'arrow')         arrowH = myArrow([startXPt,startYPt],[finalXPt,finalYPt],0.5,18,tmpLinClr);         %set(arrowH, 'EraseMode', 'xor');         delete(linH)            % the line is so simple I won't even make a comment       elseif strcmp(lower(objtype), 'line')         set(linH,'LineStyle','-');         set(linH,'Color',tmpLinClr);      % technically, this is the eqn for a circle, but      % it will look distorted when drawn on unequal axes.       elseif strcmp(lower(objtype), 'circlet')         radius = sqrt( ((startXPt-finalXPt)/2)^2 +...                        ((startYPt-finalYPt)/2)^2 );         theta=linspace(0,2*pi,300);         xdat = radius*cos(theta)+(startXPt+finalXPt)/2;         ydat = radius*sin(theta)+(startYPt+finalYPt)/2;         circH = line(xdat, ydat);         set(circH, 'Color', tmpLinClr);         %set(circH, 'EraseMode', 'xor');         delete(linH)       % this will make a 'corrected' circle which takes       % the different axis scales and lengths into account.       % (This was a _royal_ pain in the ass.)       elseif strcmp(lower(objtype), 'circles')         axDim  = get(gca,'Position');         aspRat = axDim(4)/axDim(3);         xTicks = get(gca,'XTick');         xRange = abs(xTicks(length(xTicks))-xTicks(1));         deltax = startXPt-finalXPt;         xnorm  = (deltax/xRange);         yTicks = get(gca,'YTick');         yRange = abs(yTicks(length(yTicks))-yTicks(1));         deltay = startYPt-finalYPt;         ynorm  = (deltay/yRange) * aspRat;         if xnorm            angle = 180/pi * atan(ynorm/xnorm);          else            angle = 180/pi * atan(inf);         end         if abs(angle) == 90            xx = 0;          else            xx = abs(deltax/cos((angle/180)*pi))/2;         end         if (angle == 0) | (abs(angle) == 180)            yy = 0;          else            yy = abs(deltay/sin((angle/180)*pi))/2;         end         if xx == 0, xx = yy*(xRange/yRange)*aspRat; end         if yy == 0, yy = xx*(yRange/xRange)/aspRat; end         theta = linspace(0,2*pi,300);         xdat  = xx*cos(theta) + (startXPt+finalXPt)/2;         ydat  = yy*sin(theta) + (startYPt+finalYPt)/2;         circH = line(xdat, ydat);         set(circH, 'Color', tmpLinClr);         %set(circH, 'EraseMode', 'xor');         delete(linH)       % this is way too easy for words       elseif strcmp(lower(objtype), 'rectangle')         rectH = line([startXPt startXPt finalXPt finalXPt startXPt],...                      [startYPt finalYPt finalYPt startYPt startYPt]);         set(rectH, 'Color', tmpLinClr);         set(rectH, 'EraseMode', 'xor');         delete(linH)       % this is also too easy for words       elseif strcmp(lower(objtype), 'none')         delete(linH)      end %obj type check   end  %mouse up   set(gf,'WindowButtonMotionFcn', '');   set(gf,'Pointer','arrow');   clear global startXPt newXPt startYPt newYPt   clear global finalXPt finalYPt linHend