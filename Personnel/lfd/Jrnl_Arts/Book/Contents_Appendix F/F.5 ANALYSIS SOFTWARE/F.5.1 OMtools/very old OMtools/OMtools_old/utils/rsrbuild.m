% RSRbuild.m: build a matrix of ramp-step-ramp stimuli (looks like% a "trap" stim but with saccades in the middle of each slope).%% slope values:    positive = L-->R;     negative = R-->L % saccade values:  positive = with ramp; negative = against ramp%% Must have 'rsrgen.m' to work.% Use 'saccbuild.m' to generate saccades (w/o ramps) that will be used as% the baseline to compare against the saccades made in presence of ramps% Written by:  Jonathan Jacobs%              June 1999 - September 2000 (last mod: 09/07/00)function [out, count, details] = rsrbuild( numreps )if nargin == 0  numreps = 1;end% velocities to the right and to the leftrslopelist  = [ 10  20  30];lslopelist  = [-30 -20 -10];%rslopelist  = [ 30];%lslopelist  = [-30];% saccades to be made during right rampsrsacclist   = [ 10  5  1  -1 -5  -10 ];%rsacclist   = [ 0 ];% saccades to be made during left rampslsacclist   = [ 10  5  1  -1 -5  -10 ];%lsacclist   = [ 0 ];maxpos = 30;minpos = -30;maxdur = 75;             % maximum stimulus length (seconds)pausedur = 0.0;          % pause after back-jump% 8/30/00: Why the pause?  Good question.  Basically it is there to give the % subject a better chance of making an accurate saccade.  If the pause were not % present, then the second half of the ramp would affect (like Rashbass)% the size of the saccade, since there would be calculation made based on% both the size of the jump, AND the second half of the ramp.  The pause needs% to be at least as long as the pursuit latency plus the saccadic latency, so% half a second seems to be a good choice.%% 9/7/00: Actually, there may be good reason NOT to include the pause.  When% someone pursues and the ramp stops, they continue to pursue until latency% catches up, so they are going to make a large saccade due for this reason,% if the landing point stays constant.  By not having the pause, the ramp % continues to move the landing point, and therefore the over-calculation % will be cancelled. %% 9/8/00: It turns out that the pause was a BAD IDEA.% since we will make a right ramp and a left ramp during each% 'cycle' we only need the length of one set of permutations numtypes = length(rsacclist)*length(rslopelist);sampAO = 100;     % 100 Hz analog out sample rate (LabVIEW VI default)initfix = 0.5;    % initial fixation before ramp starts     interfix = 1.5;   % fixation between trialsdur = zeros(1,numreps*numtypes);num = zeros(1,numreps*numtypes);rparam = []; lparam = [];for i = 1:numreps   lparam = [lparam, (1:numtypes)];   % l slope & its assoc (±) saccade   rparam = [rparam, (1:numtypes)];   % r slope % its assoc (±) saccadeendlparam = shuffle2(lparam);rparam = shuffle2(rparam);initseg = minpos*ones(initfix * sampAO,1);rinterseg = maxpos*ones(interfix * sampAO,1);linterseg = minpos*ones(interfix * sampAO,1);stimlist = zeros(maxdur*sampAO,1);  %count = 1;temp = [initseg];tempdur = length(temp)/sampAO;for i = 1:numtypes*numreps   % choose rsrgen parameters from the randomly shuffled lists:      % select the rightward ramp and saccade   rsaccind  = fix( (rparam(i)-1)/length(rslopelist) )+1;   rslopeind = rem( rparam(i),length(rslopelist) )+1;   rsacc(i)  = rsacclist(rsaccind);   rslope(i) = rslopelist(rslopeind);   % select the leftward ramp and saccade   lsaccind  = fix( (lparam(i)-1)/length(lslopelist) )+1;   lslopeind = rem( lparam(i),length(lslopelist) )+1;   lsacc(i)  = lsacclist(lsaccind);   lslope(i) = lslopelist(lslopeind);   % generate the ramp-step-ramps with internal pauses (see comment above)   % then combine a rightward RSR, a delay, a leftward RSR, a delay.    rsrr = rsrgen(sampAO, minpos, rslope(i), rsacc(i), pausedur, 0);    rsrl = rsrgen(sampAO, maxpos, lslope(i), lsacc(i), pausedur, 0);    newseg = [rsrr; rinterseg; rsrl; linterseg];   newsegdur(i) = length(newseg)/sampAO;      % concatentate RSR cycles until we reach the maximum duration   % and then start a new stimulus    if tempdur+newsegdur(i)<=maxdur      %disp('building...')      dur(count) = ceil(tempdur+newsegdur(i));      temp = [temp; newseg];      num(count) = num(count)+1;    else      %disp('new vector.')      dur(count) = ceil(tempdur);      stimlist(1:length(temp),count) = temp;      count = count+1;      num(count) = 1;      temp = [initseg; newseg];   end   tempdur = length(temp)/sampAO;end% don't forget the last entry!stimlist(1:length(temp),count) = temp;out = stimlist(:,1:count);% details of the stimuli to be written to file laterdetails = num2str([rslope; rsacc; lslope; lsacc; newsegdur]',3);[rows,cols]=size(details);dt = time('b',0,24,0);dt = pad(dt,cols);% separate each file's entries from the nexttemp = [];lastnum = max(find(num~=0)); a(1) = 0;for i = 1:lastnum   a(i+1) = sum(num(1:i));   filestr = ['rsr' num2str(i) '.stm  ' num2str(dur(i)) ' sec'];   filestr = pad(filestr,cols);   temp = [temp; filestr; details(a(i)+1:a(i+1),:); blanks(cols)];enddetails = [dt; temp];               % add a date and time[rows,cols]=size(details);crstring = char(13*ones(rows,1));   % and append a CR details = [details, crstring];      % to each line% plot the outputt = (1:maxdur*sampAO)/sampAO;for i=1:count   figure   plot(t,out(:,i))   xlabel(['Time (sec)'])   ylabel('Stimulus Amplitude (deg)')   title(['Ramp-Step-Ramp stimulus #' num2str(i)])end   disp(' ')disp('If you are happy with these results, you can save them as ASCII files')disp('Otherwise, run "RSRBUILD" again.')yorn=lower(input('Write these to files (y/n)? ','s'));file = 0;initialpath = pwd;if yorn=='y'   [file, path] = uiputfile('*.stm', 'Save to selected directory');endif file == 0   disp('No files written.')   eval(['cd ' '''' initialpath ''''])   return else   eval(['cd ' '''' path ''''])	for i = 1:count	   a = out(:,i);	   eval(['save rsr' num2str(i) '.stm a -ascii;'])	end	fid = fopen('rsrmatrix.txt','w');   fwrite(fid,details','char');   fclose(fid);   end