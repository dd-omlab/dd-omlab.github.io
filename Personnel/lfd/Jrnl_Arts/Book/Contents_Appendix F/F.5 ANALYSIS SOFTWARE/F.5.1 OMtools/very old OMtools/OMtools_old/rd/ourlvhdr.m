% ourlvhdr.m: reads the header for LabVIEW files generated by our computer% this is a mess, because it has evolved clumsily with no coordination% several people who have not communicated with each other before making% changes.% Written by Jonathan Jacobs% January 2002  (last mod: 03/17/03)% 3/17/03: changed f4 to read in 6 bytes, rather than 5, and deleted the% fseek(1) that follows.  this will allow for more than 99,999 samples% to be read in.% we have already read in the first 20 characters.  They contain part of the% scale values that LabVIEW used when the data was acquired.f1a = fread(fid,20,'uchar');f1astr = setstr(f1a');fseek(fid,1,'cof');f2 = fread(fid,80,'uchar');comments = setstr(f2');fseek(fid,1,'cof');f3 = fread(fid,60,'uchar');chnlstr = setstr(f3');chan_count = length(findstr(chnlstr,','))+1;fseek(fid,1,'cof');f4 = fread(fid,6,'uchar');points = str2num(setstr(f4'));%fseek(fid,1,'cof');f5 = fread(fid,4,'uchar');tempSampFreq = str2num(setstr(f5'));fseek(fid,1,'cof');f6 = fread(fid,35,'uchar');calib = str2mat(setstr(f6'));temp = fread(fid,10,'uchar');tempstr = str2mat(setstr(temp'));init_time = str2num(tempstr);f6aa = fread(fid,50,'uchar');stimstr = str2mat(setstr(f6aa'));f6a = fread(fid,5,'uchar');vers = str2num(setstr(f6a'));if isempty(vers)   vers = 1.0;endif vers >= 1.2   scaleval=str2num(f1str);endif vers == 1.3   [vpixx_stim,temp]=strtok(f1astr,',');   verge_stim = temp(2:end); elseif vers >= 1.4   scaleval=str2num([f1str f1astr]);   [vpixx_stim,temp]=strtok(stimstr,',');   verge_stim = temp(2:end); else   vpixx_stim = 'n/a';   verge_stim = 'n/a';end% new header stuff.  If we are using the OLD header% we will have to rewind the file 10 bytes (9+1 bytes)fseek(fid,1,'cof') ;f7 = fread(fid,9,'uchar') ;indic = setstr(f7') ;new_flag = strcmp(indic,'AO_PARAMS') ;only_ai_flag = strcmp(indic,'ONLY_ANIN') ;clear indicif (new_flag)   fseek(fid,1,'cof') ;   f8 = fread(fid,6,'uchar') ;   ao_smpf = str2num(setstr(f8')) ;   clear f8   fseek(fid,1,'cof') ;   f9 = fread(fid,6,'uchar') ;   n_ao_pts = str2num(setstr(f9')) ;   clear f9   fseek(fid,1,'cof') ;   f10 = fread(fid,2,'uchar') ;   n_int_arrays = str2num(setstr(f10')) ;   clear f10   fseek(fid,1,'cof') ;   f11 = fread(fid,40,'uchar') ;   ch_labels = setstr(f11') ;   clear f11   ch_lab_temp = lower(ch_labels) ;elseif (only_ai_flag)   n_int_arrays = 0 ;   ao_smpf = 0 ;   n_ao_pts = 0 ;   fseek(fid,1,'cof') ;   f11 = fread(fid,40,'uchar') ;   ch_labels = setstr(f11') ;   clear f11   ch_lab_temp = lower(ch_labels) ;else   % the is kinda clever, actually.  We calculate the size of the   % internal arrays by learning the length of the file, the length    % of the data and where we are in the file at the moment.   fseek(fid,-10,'cof') ;   ao_smpf = 100 ;   n_int_arrays = 6 ;   currentpos = ftell(fid);   fseek(fid,0,'eof');   eofpos = ftell(fid);   fseek(fid,currentpos,'bof');   datalen = chan_count*points*2;   % '*2' because data is 'short' (16 bits)   n_ao_pts = (eofpos-datalen-currentpos)/(n_int_arrays*4); % '*4' = 'long'end   