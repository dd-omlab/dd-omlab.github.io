% adj.m: asymmetrical scaling function.% Will offset and scale the last column of the data array passed to it.% Can be called with 1, 2 or 6 arguments.%% USAGE:%  1 argument:  output = adj(input)  uses the values selected in "zoomtool"%  2 arguments: output = adj(input, zero)%  6 arguments: output = adj(input, zero, [maxCalPt1..maxCalPtN], [max1..maxN],%                                         [minCalPt1..minCalPtN], [min1..minN])% EXAMPLE:% 		rh=adj(rh,0#,10,cal#,-10,cal#);% written by:  Jonathan Jacobs%              November 1995 - September 1999  (last mod: 09/30/99)function inp_data=adj(inp_data,zero_pt,max_cal_pt,max_adj,min_cal_pt,min_adj)%global xyCur1Ctr xyCur1Matif nargin == 0   help adj   returnend[dataRows, dataCols] = size( inp_data );if dataCols > 1   if dataRows == 1      inp_data = inp_data';   else      dColStr = num2str(dataCols);      disp( ['There are ' dColStr ' columns in the data array.'] )      disp(  'I will adjust only the last column added.' )   endendif nargin == 2       % use supplied zero-point.  Shift the data w/o scaling it   inp_data(:,dataCols) = inp_data(:,dataCols) - zero_pt;   return   elseif nargin == 6  % use supplied zero and max/min-adjusts. Shift & scale   inp_data(:,dataCols) = inp_data(:,dataCols) - zero_pt;      [r,~] = size(max_cal_pt);      % need a leading zero because the   z = zeros(r,1);                % first extended calibration subtraction   maxcalarray = [z max_cal_pt];  % will be around zero degrees.      [r,c] = size(min_cal_pt);   z = zeros(r,1);   mincalarray = [z min_cal_pt];      for i = 1:c      pos_pts = find( inp_data(:,dataCols)>maxcalarray(1,i) );      if isempty(pos_pts)         %disp('no pos_pts found')      else         if isnan(max_adj(i))            %         else            inp_data(pos_pts,dataCols) = ...               ((inp_data(pos_pts,dataCols)-maxcalarray(1,i))*max_adj(i)) + maxcalarray(1,i);         end      end            neg_pts = find( inp_data(:,dataCols)<mincalarray(1,i) );      if isempty(neg_pts)         %disp('no neg_pts found')      else         if isnan(min_adj(i))            %         else            inp_data(neg_pts,dataCols) = ...               ((inp_data(neg_pts,dataCols)-mincalarray(1,i))*min_adj(i)) + mincalarray(1,i);         end      end   end      returnend% nargin == 1, ie no parameters passed from keyboard, so we% use the values from xyCur1Mat (generated by zoomtool)if nargin == 1   disp('temporarily out of order')   return   %    if (xyCur1Ctr == 1) | isempty(xyCur1Mat)   % no points selected   %       disp( 'You have not selected any adjustment points yet.' )   %       disp( 'Run "zoomtool" on the data you''d like to adjust and click' )   %       disp( 'the "x,y" button to select three adjustment points.  You' )   %       disp( 'can select these points in ANY order, ''cuz I''m smart!')   %       return   %     elseif xyCur1Ctr == 2                   % only a zero adjustment   %       zero_pt = xyCur1Mat( 1, 2 );   %       inp_data(:,dataCols) = inp_data(:,dataCols) - zero_pt;   %       disp( 'You have selected only one point.  I will consider this' )   %       disp( 'the zero adjustment and will not ask for calibration' )   %       disp( 'maximum and minimum points.' )   %       disp( ' ' )   %       disp( 'You may wish to save these points for further reference.' )   %       disp( ['zero_pt: ' num2str(zero_pt)] )   %       disp( ['max_adjust: ' num2str('1')] )   %       disp( ['min_adjust: ' num2str('1')] )   %       return   %     elseif xyCur1Ctr == 3                   % only two points selected   %       disp( 'You have not selected enough adjustment points yet.' )   %       disp( 'Run "zoomtool" on the data you''d like to adjust and click' )   %       disp( 'the "x,y" button to select all three points.' )   %       return   %     elseif xyCur1Ctr > 4                    % more than three points...   %       disp( 'There are more than three adjustment points selected.' )   %       disp( 'Only the first three will be used.  If this is not ' )   %       disp( 'acceptable then you should run "zoomtool" again.' )   %       return   %   end %if xyCur1Ctr...   %   %    % nargin == 1 and xyCur1Ctr == 4   %    % automagically pick out the max, min and zero points   %    % "map" is used to find the zero, once we've blanked out the   %    % max and min positions.   %    map = [ 1 1 1 ];   %    [max_point, max_index] = max( xyCur1Mat(:,2) );   %       where_max = xyCur1Mat( max_index, 1);   %       map( max_index ) = 0;                    % clear the max map entry   %    [min_point, min_index] = min( xyCur1Mat(:,2) );   %       where_min = xyCur1Mat( min_index, 1);   %       map( min_index ) = 0;                    % clear the min map entry   %    zero_index = find( map > 0 );               % only "1" left in the map   %       zero_pt = xyCur1Mat( zero_index, 2 );   %       where_zero  = xyCur1Mat( zero_index, 1);   %       map( zero_index ) = 0;   %   %    % here comes all the scaling work...   %    % we have to do the zero corrections before we can do the scaling   %    inp_data(:,dataCols) = inp_data(:,dataCols) - zero_pt;   %    max_point = max_point - zero_pt;   %    min_point = min_point - zero_pt;   %   %    % now let's get our calibration values   %    disp( 'Enter "q" to cancel' )   %    max_cal = input( 'What is the maximum calibration value?  ','s');   %    if ( strcmp(lower(max_cal), 'q') )   %       disp( 'Cancelling.')   %       return   %    end   %    max_cal = str2num( max_cal);   %   %    min_cal = input( 'What is the minimum calibration value?  ','s');   %    if ( strcmp(lower(min_cal), 'q') )   %       disp( 'Cancelling.')   %       return   %    end   %    min_cal = str2num( min_cal);   %   %    % scale max and min   %    max_adjust = max_cal/max_point;   %    pos_points = find( inp_data(:,dataCols) > 0 );   %    inp_data(pos_points,dataCols) = inp_data(pos_points,dataCols)*max_adjust;   %   %    min_adjust = min_cal/min_point;   %    neg_points = find( inp_data(:,dataCols) < 0 );   %    inp_data(neg_points,dataCols) = inp_data(neg_points,dataCols)*min_adjust;   %   %    disp( 'You may wish to save these points for further reference.' )   %    disp( ['zero_pt: ' num2str(zero_pt)] )   %    disp( ['max_adjust: ' num2str(max_adjust)] )   %    disp( ['min_adjust: ' num2str(min_adjust)] )   %    returnend %"if nargin == 1"% any other number of input arguments is silly. Same message as for nargin == 0disp('"adj" requires the name of a data array on which to operate.')disp('Or you may call "adj" with precalculated adjustment parameters')disp('Example: "rh = adj(rh)" or "rh = adj( rh, zero, max_adj, min_adj)"')