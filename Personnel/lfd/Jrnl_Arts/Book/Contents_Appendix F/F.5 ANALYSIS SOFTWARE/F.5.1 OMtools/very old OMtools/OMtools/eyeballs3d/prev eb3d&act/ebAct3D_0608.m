% ebAct3D.m: Called by 'eyeballs3D' to perform all the callback actions%% Written by: Jonathan Jacobs%             March 2002 - May 2005 (last mod: 05/11/05)% Files necessary for proper operation:%   'eyeballs3d', 'ebAct3D.m', 'datscale.m', 'd2pt.m', 'axispad.m',%   'xyplotsettings.m', 'ebdatacheck.m', 'ebdataload.m'%%% Major updates and fixes:% 27 Nov 02: Added alignment crosshairs. May eventually make them%  2 Dec 02: Added 'crossH' variable; allow turning crosshairs on/off%            The wform, monitor and control windows created at proper size,%              rather than resizing them after creation.% 29 May 03: Massive redesign of GUI, relocation of many controls%            Added user-customizable XY plot settings.%            'play' reads settings from XY plot's axis and applies values%              to XY plot playback%  2 Jun 03: Major revision now allows loading of new data w/o having to%              close and re-run 'eyeballs3d'%  5 Jun 03: User can now select arrays from the base workspace for XY plot% 16 Jul 03: Added optional display of stimulus data% 14 Oct 03: Added rubberband zoom% 12 Jan 05: Rewrote movie making code, prefs. reorganized movie prefs.%            Render animation using 'zbuffer' workaround for 'OpenGL' bug.%            User can now specify QT (if available), AVI, or series of JPEGs% 21 Jan 05: Eyeball and waveform windows are now easily resizable via%              slider/text box controls% 28 Jan 05: Thanks to effing Microsoft's crap handling of non-native graphics%					and movie formats, eyeballs now can be rendered w/o grid lines%              so the drastically reduced quality in PowerPoint is not as easily%              noticable.% 01 Feb 05: scale values are stored in the wf FIGURE'S 'UserData' now,%              rather than in that for the individual AXES'.%              This fixes the necessity of the axes being displayed in the wf%              window for scaling to be available.% 02 Feb 05: added extra cells to wf_axXY 'UserData' field as placeholders%              for the phase plane data arrays to enable stepping through%              the data ONLY AFTER it has been played at least once.% 09 May 05: zillions of little fixes. wf window resizes properly and is drawn%              at the proper size at startup. cosmetic rejiggering of axis sizes and%              positions when resizing the wf window. 'Stop' slider restored to%              proper position following cancellation of playback.%              Adjusting start/current/stop sliders when XY plot is enabled, but%              before 1st playback no longer causes a crash.%              'xyplotsettings' has been extensively updated.% valid commands ('buttName' arg string):%   about, rbzoom, resize, speed, eyelight, eyeliner%   start_txt, start_sli, stop_txt, stop_sli%   cur_txt, cur_sli, f_cur, f_start, f_stop%   xy_setup, play!, hvt_update%   color, crosshairs, tormrkr, wf_draw%   load_data, movieprefs, done!function ebAct3D(buttName)global rh lh rv lv rt lt st sv samp_freq dataname %#ok<NUSED>global ebtempresultcomp=computer;vers=version;if comp(1)=='M' && vers(1)=='5'   moviemode = 'qt';else   moviemode = 'avi';enddegstr=char(176);%pmstr=char(177);cfig=findwind('Eye Monitor Control');efig=findwind('Eye Monitor');wfig=findwind('Waveform Monitor');sfig=findwind('Data Scaling & Offset');xyfig=findwind('XY Plot settings');if ~ishandle(cfig),disp('Control Window does not exist. Yikes.'); return; endif ~ishandle(wfig),disp('Waveform Window does not exist. Yikes.'); return; endif ~ishandle(efig),disp('Eyeballs Window does not exist. Yikes.'); return; end% verify that there is good data in memory% should not need this here, once 'ebdataload' is in callback for 'load data' button%[status, datlen, noHOR, noVRT, noTOR, noSTM] = ebdatacheck;%if status==0, break; end% retrieve the handles for the eyeball window objects. They were declared% in 'eyeballs3D'.eH = efig.UserData;osSocket=eH{1}; os=eH{2}; osMrkr=eH{3};odSocket=eH{4}; od=eH{5}; odMrkr=eH{6};overlay=eH{7};  btxt=eH{8};btxtstr=btxt.String;% retrieve the handles for the control window objects. They were declared% in 'eyeballs3D'.cH=cfig.UserData;plotHORh=cH(1);		plotVRTh=cH(2);		plotTORh=cH(3);   	decimateH=cH(7);  	fpsH=cH(8);livemonBH=cH(9);		e_movieBH=cH(10);		wf_movieBH=cH(11);	eb_size_sli=cH(13);	wf_size_sli=cH(14);	eb_size_txt=cH(16);	wf_size_txt=cH(17);	start_sli=cH(19);		stop_sli=cH(20);		cur_sli=cH(21);start_txt=cH(22);		stop_txt=cH(23);		cur_txt=cH(24);start_txt2=cH(25);	stop_txt2=cH(26);		cur_txt2=cH(27);movPrefsBH=cH(28);	crossH=cH(29);			plotXYh=cH(30);plotSTMh=cH(33);		eyelinerBH=cH(35);	eyelightBH=cH(36);% Retrieve the handles for the waveform window objects. They will be all% empty gobjects when initialized in 'eyeballs3D'. Almost immediately after% initialization, 'ebAct3D('wf_draw')' was called and the handles then have% their proper values. There is a fine line between tricky and skanky.temp=wfig.UserData;planes=temp{1}; wH=temp{2}; o_and_s=temp{3}; wf_ax_inited=temp{4};wf_axLH=wH(1);  wf_overLH=wH(2);  wf_axLV=wH(3);    wf_overLV=wH(4);wf_axLT=wH(5);  wf_overLT=wH(6);  wf_axRH=wH(7);    wf_overRH=wH(8);wf_axRV=wH(9);  wf_overRV=wH(10); wf_axRT=wH(11);   wf_overRT=wH(12);wf_axXY=wH(13); wf_dataXY=wH(14); wf_overXY=wH(15);%%%%%%%%%%%eyeliner = eyelinerBH.Value;eyelight = eyelightBH.Value;eyeColor = od.UserData;% Because we could be working with data loaded after the initial% setup of the controls, we must reset the controls' max rangedatlen=length(lh);start_sli.Max=datlen;stop_sli.Max=datlen;cur_sli.Max=datlen;startpt=round(start_sli.Value);if startpt>datlen,startpt=1;start_sli.Value=startpt;endstoppt=round(stop_sli.Value);if stoppt>datlen,stoppt=datlen;stop_sli.Value=stoppt;endcurpt=round(cur_sli.Value);if curpt>datlen,curpt=startpt;cur_sli.Value=curpt;endlivemonitor=livemonBH.Value;playstep=fix(str2double(decimateH.String));%%%fps = samp_freq/playstep;t=(1:length(lh))/samp_freq;% make sure we have the most recent movie making prefsmovtemp=movPrefsBH.UserData;%qtcompressor = movtemp{1};   spatialqual  = movtemp{2};%makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};%movie_speed  = movtemp{5};make_avi     = movtemp{6};make_stills  = movtemp{7};% Four possible axes to draw: hor, vrt, tor and phase plane (ppl)plotHOR = strfind(planes,'h'); if isempty(plotHOR),plotHOR=0; endplotVRT = strfind(planes,'v'); if isempty(plotVRT),plotVRT=0; endplotTOR = strfind(planes,'t'); if isempty(plotTOR),plotTOR=0; endplotHOR = plotHOR & plotHORh.Value;plotVRT = plotVRT & plotVRTh.Value;plotTOR = plotTOR & plotTORh.Value;plotXY  = plotXYh.Value;numplanes=sum(plotHOR+plotVRT+plotTOR);num_ax=2*numplanes;% since XY uses only one axisnumplanes=numplanes+sum(plotXY);if plotXY, num_ax=num_ax+1; end%%% Data scaling and offsetting is checked/performed EVERY time ebAct3D%%% is called, to guarantee that the most up-to-date modifications are%%% being used.% if the scaling and offset window is open, the offset & scaling% factors will be read directly from its controls.% if it is NOT open, check to see if the wf window has been initialized.% if so, there are previously-set o&s values stored in the fig's 'UserData'.% if the window is brand new, then initialize o&s values to 0 & 1.if ishandle(sfig)   % get the o/s control handles   hlist = sfig.UserData;   rh_scaleH=hlist(1);   rv_scaleH=hlist(2);   rt_scaleH=hlist(3);   rh_offsetH=hlist(4);  rv_offsetH=hlist(5);  rt_offsetH=hlist(6);   lh_scaleH=hlist(7);   lv_scaleH=hlist(8);   lt_scaleH=hlist(9);   lh_offsetH=hlist(10); lv_offsetH=hlist(11); lt_offsetH=hlist(12);      lh_scale=str2double(lh_scaleH.String);   rh_scale=str2double(rh_scaleH.String);   lv_scale=str2double(lv_scaleH.String);   rv_scale=str2double(rv_scaleH.String);   lt_scale=str2double(lt_scaleH.String);   rt_scale=str2double(rt_scaleH.String);      lh_offset=str2double(lh_offsetH.String);   rh_offset=str2double(rh_offsetH.String);   lv_offset=str2double(lv_offsetH.String);   rv_offset=str2double(rv_offsetH.String);   lt_offset=str2double(lt_offsetH.String);   rt_offset=str2double(rt_offsetH.String);   elseif wf_ax_inited   offset = o_and_s{1}; scale = o_and_s{2};      rh_scale=scale(1,1); rh_offset=offset(1,1);   lh_scale=scale(1,2); lh_offset=offset(1,2);   rv_scale=scale(2,1); rv_offset=offset(2,1);   lv_scale=scale(2,2); lv_offset=offset(2,2);   rt_scale=scale(3,1); rt_offset=offset(3,1);   lt_scale=scale(3,2); lt_offset=offset(3,2);   else   lh_scale=1; lv_scale=1; lt_scale=1; lh_offset=0; lv_offset=0; lt_offset=0;   rh_scale=1; rv_scale=1; rt_scale=1; rh_offset=0; rv_offset=0; rt_offset=0;endlhs=lh*lh_scale+lh_offset; rhs=rh*rh_scale+rh_offset;lvs=lv*lv_scale+lv_offset; rvs=rv*rv_scale+rv_offset;lts=lt*lt_scale+lt_offset; rts=rt*rt_scale+rt_offset;maxLHS=max(lhs(startpt:stoppt)); minLHS=min(lhs(startpt:stoppt));maxLVS=max(lvs(startpt:stoppt)); minLVS=min(lvs(startpt:stoppt));maxLTS=max(lts(startpt:stoppt)); minLTS=min(lts(startpt:stoppt));maxRHS=max(rhs(startpt:stoppt)); minRHS=min(rhs(startpt:stoppt));maxRVS=max(rvs(startpt:stoppt)); minRVS=min(rvs(startpt:stoppt));maxRTS=max(rts(startpt:stoppt)); minRTS=min(rts(startpt:stoppt));[minRHS, maxRHS] = axispad(minRHS,maxRHS);[minLHS, maxLHS] = axispad(minLHS,maxLHS);[minRVS, maxRVS] = axispad(minRVS,maxRVS);[minLVS, maxLVS] = axispad(minLVS,maxLVS);[minRTS, maxRTS] = axispad(minRTS,maxRTS);[minLTS, maxLTS] = axispad(minLTS,maxLTS);%%%%%%%%%%%% now for the individual button callbacks %%%%%%%%%%%%%%%%if strcmpi(buttName,'about')   aboutStr = {'Eyeballs3D -- Version 5.0,  June 2019';      ' ';      'Written by Jonathan Jacobs, Ph.D. (jxj24@case.edu)';      ' ';      'Ocular-Motor Neurophysiology Lab (www.OMLAB.org)';      'VA Medical Center, Cleveland, OH';      ' ';      'Depts. of Neurology (School of Medicine)';      '       and Biomedical Engineering';      'Case Western Reserve University';      ' ';      'All rights reserved. All wrongs reversed.';      '(copyleft) 2002 - 2019';      ' '};   msgbox(aboutStr,'About "Eyeballs"')      elseif strcmpi(buttName,'set_idstr')   btxtstr=input('Enter movie badging text: ','s');   btxt.String=btxtstr;   elseif strcmpi(buttName, 'rbzoom')   if get(gco,'Value')==1      set(gco,'String','On')      figure(wfig)      zoom on   else      set(gco,'String','Off')      figure(wfig)      zoom off      % update all the damn sliders and text boxes; make sure all axes are equal      xlims=get(gca,'XLim')*samp_freq;      start_sli.Value=xlims(1);      ebAct3D('start_sli');      stop_sli.Value=xlims(2);      ebAct3D('stop_sli');   end      elseif strcmpi(buttName,'resize')      if strcmpi(buttName(8:9),'eb')      if strcmpi(buttName(11:13),'sli')         eb_size = get(gco,'Value');         eb_size_txt.String=num2str(eb_size,3);   %% 2?  or 3?      elseif strcmpi(buttName(11:13),'txt')         eb_size=str2double(eb_size_txt.String);         if isempty(eb_size) || (eb_size>1) || (eb_size<0.5)            eb_size=eb_size_sli.Value;            eb_size_txt.String=num2str(eb_size,3);         end         eb_size_sli.Value=eb_size;      end      windH=efig;      wscale=eb_size;      maxwidth=570; maxheight=264;         elseif strcmpi(buttName(8:9),'wf')      if strcmpi(buttName(11:13),'sli')         wf_size = get(gco,'Value');         wf_size_txt.String=num2str(wf_size,3);   %% 2?  or 3?      elseif strcmpi(buttName(11:13), 'txt')         wf_size = str2double(wf_size_txt.String);         if isempty(wf_size) || (wf_size>1) || (wf_size<0.5)            wf_size=wf_size_sli.Value;            wf_size_txt.String=num2str(wf_size,3);         end         wf_size_sli.Value=wf_size;      end      windH=wfig;      wscale=wf_size;      maxwidth=300;      maxheightlist=[280 540 670 810];      %% [255 507 640 780]      maxheight=maxheightlist(numplanes);   end      % get the position of the target window and find its center.   % we will resize around the center so window appears to shrink/grow   % equally in all directions. neato.   wpos=windH.Position;   x0=wpos(1); y0=wpos(2); width=wpos(3); height=wpos(4);   center = [x0+width/2, y0+height/2];   new_wid = maxwidth*wscale;   new_hgt = maxheight*wscale;   new_x0  = center(1)-new_wid/2;   new_y0  = center(2)-new_hgt/2;   windH.Position=[new_x0, new_y0, new_wid, new_hgt];      % will we worry about the size of the text in the title, x/y labels?   % would be nice if smallifying windows below some thresh reduced the   % text to a more appropriate size. ditto for embigulating them.   % the children of the waveform window are axes (from 1 to 7 depending   % on how many dimensions are being displayed).   if windH==wfig      if wscale>0.85         titleFSize=14; xyFSize=12;      elseif wscale>0.7         titleFSize=12; xyFSize=10;      elseif wscale>0.6         titleFSize=10; xyFSize=8;      elseif wscale>=0.5         titleFSize=8; xyFSize=6;      end            axlist=windH.Children;      for ch=1:length(axlist)         titleH=axlist(ch).Title;         %tfontsize = get(titleH,'FontSize');         titleH.FontSize=titleFSize;         xlabelH=axlist(ch).XLabel;         %xfontsize = get(xlabelH,'FontSize');         xlabelH.FontSize=xyFSize;         ylabelH = axlist(ch).YLabel;         %yfontsize = get(ylabelH,'FontSize');         ylabelH.FontSize=xyFSize;      end   end      % and just for fun, we substitute a less complex eyeball if the   % window starts feeling crowded.   if windH==efig      ebmap=ones(128,3);      if wscale >= 0.8         [z,y,x]=sphere(40);         ebmap(127:128,:) = zeros(2,3);         ebmap(119:126,1) = eyeColor(1);         ebmap(119:126,2) = eyeColor(2);         ebmap(119:126,3) = eyeColor(3);      elseif wscale >= 0.5         [z,y,x]=sphere(24);         ebmap(126:128,:) = zeros(3,3);         ebmap(117:125,1) = eyeColor(1);         ebmap(117:125,2) = eyeColor(2);         ebmap(117:125,3) = eyeColor(3);      end      figure(efig)      temp=surf(x,y,z,x,'Visible','off');      cdata=temp.CData;      delete(temp)      set(od,'XData',x,'YData',y,'ZData',z,'CData',cdata)      set(os,'XData',x,'YData',y,'ZData',z,'CData',cdata)      efig.Colormap=ebmap;   end      elseif contains(buttName,'speed')   % link the decimate and fps values   fps=str2double(fpsH.String);   dec=str2double(decimateH.String);      if strcmpi(buttName(7),'d')      fps=fix(samp_freq/dec);      fpsH.String=num2str(fps,'%d');   elseif strcmpi(buttName(7),'f')      dec=fix(samp_freq/fps);      decimateH.String=num2str(dec,'%d');   end      elseif strcmpi(buttName,'eyelight')   ouLightH=eyelightBH.UserData;   odLightH=ouLightH(1);   osLightH=ouLightH(2);   if eyelight==1      axes(odSocket)      odLightH = camlight(0,10);      axes(osSocket)      osLightH = camlight(0,10);      eyelightBH.UserData=[odLightH osLightH];   else      delete(odLightH);      delete(osLightH);   end   axes(overlay)      elseif strcmpi(buttName,'eyeliner')   if eyeliner==0      os.LineStyle='none';      od.LineStyle='none';   else      os.LineStyle='-';      od.LineStyle='-';   end      elseif strcmpi(buttName,'start_txt')   startpt = str2double(start_txt.String);   if isempty(startpt), startpt=round(start_sli.Value); end   start_sli.Value=startpt;   ebAct3D('start_sli')      elseif strcmpi(buttName, 'start_sli')   if startpt>=stoppt, startpt=stoppt-1; end   startpt = max(startpt,1);   startpt=fix(startpt);   start_sli.Value=startpt;   start_txt.String=num2str(startpt);   start_txt2.String=num2str(startpt/samp_freq);   %%%curpt = max(startpt,curpt);   ebAct3D('cur_sli')   if plotHOR      wf_axLH.XLim=[startpt/samp_freq stoppt/samp_freq];      wf_axRH.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLHS~=maxLHS, wf_axLH.YLim=[minLHS maxLHS]; end      if minRHS~=maxRHS, wf_axRH.YLim=[minRHS maxRHS]; end   end   if plotVRT      wf_axLV.XLim=[startpt/samp_freq stoppt/samp_freq];      wf_axRV.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLVS~=maxLVS, wf_axLV.YLim=[minLVS maxLVS]; end      if minRVS~=maxRVS, wf_axRV.YLim=[minRVS maxRVS]; end   end   if plotTOR      wf_axLT.XLim=[startpt/samp_freq stoppt/samp_freq];      wf_axRT.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLTS~=maxLTS, wf_axLT.YLim=[minLTS maxLTS]; end      if minRTS~=maxRTS, wf_axRT.YLim=[minRTS maxRTS]; end   end      elseif strcmpi(buttName,'stop_txt')   stoppt = str2double(stop_txt.String);   if isempty(stoppt), stoppt=round(stop_sli.Value); end   stop_sli.Value=stoppt;   ebAct3D('stop_sli')      elseif strcmpi(buttName,'stop_sli')   if stoppt<=startpt, stoppt=startpt+1; end   stoppt=min(stoppt,datlen);   stoppt=round(stoppt);   stop_sli.Value=stoppt;   stop_txt.String=num2str(stoppt);   stop_txt2.String=num2str(stoppt/samp_freq);   %%%curpt = min(stoppt,curpt);   ebAct3D('cur_sli')   if plotHOR      wf_axLH.XLim=[startpt/samp_freq stoppt/samp_freq];      wf_axRH.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLHS~=maxLHS, wf_axLH.YLim=[minLHS maxLHS]; end      if minRHS~=maxRHS, wf_axRH.YLim=[minRHS maxRHS]; end   end   if plotVRT      wf_axLV.XLim=[startpt/samp_freq stoppt/samp_freq];      wf_axRV.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLVS~=maxLVS, wf_axLV.YLim=[minLVS maxLVS]; end      if minRVS~=maxRVS, wf_axRV.YLim=[minRVS maxRVS]; end   end   if plotTOR      wf_axLT.XLim=[startpt/samp_freq stoppt/samp_freq];      wf_axRT.XLim=[startpt/samp_freq stoppt/samp_freq];      if minLTS~=maxLTS, wf_axLT.YLim=[minLTS maxLTS]; end      if minRTS~=maxRTS, wf_axRT.YLim=[minRTS maxRTS]; end   end      elseif strcmpi(buttName(1:3), 'cur')     %% 'cur_txt', 'cur_sli'   if strcmpi(buttName(5:7), 'txt')      curpt=str2double(cur_txt.String);   end   if isempty(curpt),curpt=round(cur_sli.Value); end   if curpt<startpt, curpt=startpt; end   if curpt>stoppt,  curpt=stoppt; end   curpt=fix(curpt);   cur_sli.Value=curpt;   cur_txt.String=num2str(curpt);   cur_txt2.String=num2str(curpt/samp_freq);   osSocket.View=[lhs(curpt)+90 -lvs(curpt)];   odSocket.View=[rhs(curpt)+90 -rvs(curpt)];   prev_tor(1)=osSocket.UserData;   prev_tor(2)=odSocket.UserData;   rotate( os,[1 0 0],     lts(curpt)-prev_tor(1) );   rotate( od,[1 0 0],     rts(curpt)-prev_tor(2) );   rotate( osMrkr,[1 0 0], lts(curpt)-prev_tor(1) );   rotate( odMrkr,[1 0 0], rts(curpt)-prev_tor(2) );   prev_tor = [lts(curpt) rts(curpt)];   osSocket.UserData=prev_tor(1);   odSocket.UserData=prev_tor(2);   ebAct3D('hvt_update')      elseif strcmpi(buttName(1), 'f')   if strcmpi(buttName(3:5), 'cur')      new_cur=str2double(cur_txt2.String)*samp_freq;      cur_txt.String=num2str(new_cur);      ebAct3D('cur_txt')   elseif strcmpi(buttName(3:6), 'stop')      new_stop=str2double(stop_txt2.String)*samp_freq;      stop_txt.String=num2str(new_stop);      ebAct3D('stop_txt')   elseif strcmpi(buttName(3:7), 'start')      new_start=str2double(start_txt2.String)*samp_freq;      start_txt.String=num2str(new_start);      ebAct3D('start_txt')   end      elseif strcmpi(buttName,'xy_setup')   xyplotenabled=plotXYh.Value;   if xyplotenabled      xyplotsettings('initialize')   end      elseif strcmpi(buttName,'play!')   pbH=gco;   %if cur_sli.Value < get(stop_sli,'Value')   if pbH.UserData==1      disp('Playback in progress. Please wait.')      return   end   pbH.UserData=1;   % allocate space for the movie(s)   %rect = [245 7 96 96]; capture only OS      make_e_movie=e_movieBH.Value;   if make_e_movie      numframes = length(startpt:playstep:stoppt);      e_movie=moviein(numframes,efig);      j=1;   end   make_wf_movie=wf_movieBH.Value;   if make_wf_movie      numframes = length(startpt:playstep:stoppt);      wf_movie=moviein(numframes,wfig);      k=1;   end         % clear the torsions   prev_tor(1)=osSocket.UserData;   prev_tor(2)=odSocket.UserData;   rotate( os,[1 0 0],     prev_tor(1) );   rotate( od,[1 0 0],     prev_tor(2) );   rotate( osMrkr,[1 0 0], prev_tor(1) );   rotate( odMrkr,[1 0 0], prev_tor(2) );      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%%%%%%   start of XY plot setup   %%%%%%%%%%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   if plotXY      % load the settings from the XYplot axis' 'UserData'  They were stored      % there by the 'Apply' or 'Done' commands in 'xyplotsettings.m'      % if you try to play w/o first initializing the xy settings, the xy init      % window will be called, and nothing can happen until it is dismissed.      temp=wf_axXY.Userdata;      xy_val=temp{1};      if ~iscell(xy_val)         xyplotsettings('initialize')         uiwait         temp=wf_axXY.Userdata;         xy_val=temp{1};      end            %windowtitle  = xy_val{1};   xdata1       = xy_val{2};      %xdata1vel    = xy_val{3};   xdata1acc    = xy_val{4};      %xdata1label  = xy_val{5};   xdata1other  = xy_val{6};      %ydata1       = xy_val{7};   ydata1vel    = xy_val{8};      %ydata1acc    = xy_val{9};   ydata1label  = xy_val{10};      %xdata1other = xy_val{11};   xlowlim      = xy_val{12};      %xhighlim     = xy_val{13};  ylowlim      = xy_val{14};      %yhighlim     = xy_val{15};        line1color   = xy_val{16};      line1style   = xy_val{17};  head1color   = xy_val{18};      head1symbol  = xy_val{19};  history      = xy_val{20};      %fplimh	    = xy_val{21};  fplimv       = xy_val{22};      %fvlim        = xy_val{23};        samp_or_sec  = xy_val{24};      %wt_locked    = xy_val{25};  xl_locked    = xy_val{26};      %yl_locked    = xy_val{27};        x_dat_str    = xy_val{28};      y_dat_str    = xy_val{29};            % set the color/style/symbol popup menu string      colorlist = ['r' 'y' 'g' 'b' 'c' 'm' 'w' 'k'];      stylelist = ['-' '--' ':' '-.'];      symbolist = ['o' 's' '^' 'x' '*' 'd' 'h'];            line1colorstr  = colorlist(line1color);      line1stylestr  = stylelist(line1style);      head1colorstr  = colorlist(head1color);      head1symbolstr = symbolist(head1symbol);            % If second word of x_data_str is 'other', the user selected data directly      % from the workspace, and should not be modified, just placed in 'xtemp'.      % Otherwise, use 'eval' to place the actual data into 'xtemp', which will      % be differentiated as needed, and the subarray as selected by the 'start'      % and 'stop' controls will be placed into 'XData' for playback.      % 	The 's' appended to 'x_chan' turns e.g. 'lh' into 'lhs', which is the      % scaled and offset version of 'lh'. (Don't do this for 'other' data.)      % Ditto for 'YData'.      [x_chan, temp] = strtok(x_dat_str,','); x_deriv=temp(2:end);      if strcmpi(x_deriv,'other')         % have to pull the same fugly trick as we did in 'xyplotsettings'         %(in the strfind(xybutton,'other') code) to create a temporary global         % variable, both here and in the base workspace, that will allow us to         % access the array specified in the 'other' control.         evalin('base','global ebtempresult')         evalin('base',['ebtempresult = ' x_chan ';'])         xtemp = ebtempresult;         clear global ebtempresult      else         xtemp=NaN;         eval(['xtemp = ' x_chan 's;'])         if x_deriv(1)=='v'            xtemp=d2pt(xtemp,2);         elseif x_deriv(1)=='a'            xtemp=d2pt(xtemp,2); xtemp=d2pt(xtemp,2);         end      end            [y_chan, temp] = strtok(y_dat_str,','); y_deriv=temp(2:end);      if strcmpi(y_deriv,'other')         %global ebtempresult         evalin('base','global ebtempresult')         evalin('base',['ebtempresult = ' y_chan ';'])         ytemp = ebtempresult;         clear global ebtempresult      else         ytemp=NaN;         eval(['ytemp = ' y_chan 's;'])         if y_deriv(1)=='v'            ytemp=d2pt(ytemp,2);         elseif y_deriv(1)=='a'            ytemp=d2pt(ytemp,2); ytemp=d2pt(ytemp,2);         end      end            history = abs(str2double(history));      if samp_or_sec == 1                       % time         timeshift = round(history*samp_freq);      else                                     % samples         timeshift = round(history);      end      xdata = xtemp(startpt:stoppt);      ydata = ytemp(startpt:stoppt);            frontpad = NaN * ones(timeshift,1);      ppdata_x = [frontpad; xdata];      ppdata_y = [frontpad; ydata];            % calculate the x,y axis limits.      % moved this to 'xyplotsettings'      %xmax=max(xdata); xmin=min(xdata);      %ymax=max(ydata); ymin=min(ydata);      %xrange = xmax-xmin;      %yrange = ymax-ymin;      %xmincalc = xmin - 0.1*xrange; xmaxcalc = xmax + 0.1*xrange;      %ymincalc = ymin - 0.1*yrange; ymaxcalc = ymax + 0.1*yrange;            % If any of the axis limits fields from xyplotsettings have manual entries      % use those. Otherwise use the calculated limit(s)      %if isempty(str2double(xlowlim)),  xmin=xmincalc; else xmin=str2double(xlowlim);  end      %if isempty(str2double(xhighlim)), xmax=xmaxcalc; else xmax=str2double(xhighlim); end      %if isempty(str2double(ylowlim)),  ymin=ymincalc; else ymin=str2double(ylowlim);  end      %if isempty(str2double(yhighlim)), ymax=ymaxcalc; else ymax=str2double(yhighlim); end            %if xmin==xmax,xmin=xmin-eps;xmax=xmax+eps; end      %if ymin==ymax,ymin=ymin-eps;ymax=ymax+eps; end            %%%xlowlim=str2double(xlowlim); xhighlim=str2double(xhighlim);      %%%ylowlim=str2double(ylowlim); yhighlim=str2double(yhighlim);      %set(wf_axXY,'XLim',[xlowlim xhighlim],'YLim',[ylowlim yhighlim])            set(wf_dataXY,'Color',line1colorstr, 'LineStyle', line1stylestr)      set(wf_dataXY,'XData',[],'YData',[])      set(wf_overXY, 'Color',head1colorstr, 'Marker', head1symbolstr,...         'MarkerFaceColor',head1colorstr,'MarkerEdgeColor','w')      wf_overXY.XData=[];      wf_overXY.YData=[];            figure(wfig); hold on      wf_axXY.UserData={xy_val,{ppdata_x ppdata_y} 1};         end   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%%%%%%   end of XYplot setup   %%%%%%%%%%%%%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      t_betw_frames=playstep/samp_freq;   i=startpt;      % this is the animation loop. it is inherently slow, thanks to the very   % time consuming call to 'drawnow.' I suspect that there is nothing that   % will ever improve its performance. Best time between frames, even with   % 'live monitor' off is ~0.075 seconds for large eyeballs.   % (measured on dual GHz G4, ML7.01 (R14,SP1), OS X 10.3.7)      %profile on   a=1; %p=0;   while i<=stoppt      stoppt=round(stop_sli.Value);  % can stop animation in the middle      tic;      osSocket.View=[lhs(i)+90 -lvs(i)];      odSocket.View=[rhs(i)+90 -rvs(i)];      if lts(i)         rotate(os,[1 0 0],     lts(i)-prev_tor(1));         rotate(osMrkr,[1 0 0], lts(i)-prev_tor(1));      end      if rts(i)         rotate(od,[1 0 0],     rts(i)-prev_tor(2));         rotate(odMrkr,[1 0 0], rts(i)-prev_tor(2));      end      prev_tor=[lts(i) rts(i)];            cur_sli.Value=i;      cur_txt.String=num2str(i);      cur_txt2.String=num2str(i/samp_freq);            % get the eyeball frame      if make_e_movie         drawnow;         e_movie(:,j)=getframe(efig);         j=j+1;      end            % update the waveform window. (frippery)      % used to be a single call to 'ebAct3D('hvt_update')' but the recursive      % nature of that call adds a lot of extra overhead. such is life.      i = cur_sli.Value;      if livemonitor         xval=i/samp_freq;                  if plotHOR            wf_overLH.XData=xval;            wf_overLH.YData=lhs(i);            wf_overRH.XData=xval;            wf_overRH.YData=rhs(i);         end         if plotVRT            wf_overLV.XData=xval;            wf_overLV.YData=lvs(i);            wf_overRV.XData=xval;            wf_overRV.YData=rvs(i);         end         if plotTOR            wf_overLT.XData=xval;            wf_overLT.YData=lts(i);            wf_overRT.XData=xval;            wf_overRT.YData=rts(i);         end         if plotXY            % we had to tack some NaN data onto the beginning of the            % array (and shift it) so we can have some history to display.            ind=i-startpt+1;            wf_dataXY.XData=ppdata_x(ind:timeshift+ind);            wf_dataXY.YData=ppdata_y(ind:timeshift+ind);            wf_overXY.XData=ppdata_x(timeshift+ind);            wf_overXY.YData=ppdata_y(timeshift+ind);         end      end      % get the waveform frame      if make_wf_movie         drawnow         wf_movie(:,k)=getframe(wfig);         k=k+1;      end            drawnow      %t1(a)=toc; a=a+1;      t1=toc; a=a+1;      %t1=toc;      time_to_pause=1000*(t_betw_frames-t1);  %in milliseconds      if time_to_pause>0         mypause(time_to_pause)         %p=p+1;      end      i=i+playstep;   end      %profile viewer   %keyboard   % eyes front, mister!   mypause(150)   osSocket.View=[0+90 0];   odSocket.View=[0+90 0];   osSocket.UserData=0;   odSocket.UserData=0;   rotate( os,[1 0 0],     -prev_tor(1) );   rotate( od,[1 0 0],     -prev_tor(2) );   rotate( osMrkr,[1 0 0], -prev_tor(1) );   rotate( odMrkr,[1 0 0], -prev_tor(2) );   drawnow      % clear the wform markers   if plotHOR, wf_overLH.YData=NaN; wf_overRH.YData=NaN; end   if plotVRT, wf_overRV.YData=NaN; wf_overLV.YData=NaN; end   if plotTOR, wf_overRT.YData=NaN; wf_overLT.YData=NaN; end      %%prev_tor = 0; % unneeded for 'play'?      % playback is over   pbH.UserData=0;   old_dir=pwd;      % if user hit 'stop' button, the 'stop' slider is wrong. Fix it.   stop_sli.Value=str2double(stop_txt.String);      imageformats = {'jpeg','png','tiff','gif'};   imageformatstr = imageformats{imageformat};      % save the movie(s)   % if neither wf nor eye movies are selected, 'start' remains > 'stop'   start = 2; stop = 1;   if make_e_movie,  start=1; which_movie{1}='e_movie';  end   if make_wf_movie, stop=2;  which_movie{2}='wf_movie'; end      prompt{1}='Save the eyeball movie as:';   prompt{2}='Save the waveform movie as:';      for m = start:stop  %% if start>stop, nothing is executed      [fn,pn]=uiputfile({'*.mov;*.avi;*.*'},prompt{m});      if fn==0, return, end      [fn,~]=strtok(fn,'.');      if pn         %map=get(wfig,'colormap');         tempmap=colormap; %#ok<NASGU>         cd(pn)         switch lower(moviemode(1))            case 'q'               moviename = [fn '.mov']; %#ok<NASGU>               eval([ 'qtwrite(' which_movie{m} ', tempmap, moviename, ' ...                  '[fps/movie_speed, qtcompressor, spatialqual])' ]);            otherwise               % save the movie frames as individual images and use QuickTime               % to turn them into a real movie, not this AVI shit.               % First, make sure that we are writing frames to new folder               if make_stills                  framefold=[fn '_frames'];                  temp=dir; maxnum=0;                  foldname=framefold;  %% our inital & default condition                  for i=1:length(temp)                     % name already exists?  maybe more than one?  append a number to                     % the name e.g. 'test_frames1', ... 'test_frames_10',...                     % the created folder name will be one higher than the previous                     % highest. will NOT fill in gaps below highest number                     tempname = temp(i).name;                     if contains(tempname,framefold)  % name DOES already exist                        % look for appended number                        %num = str2double(tempname(find(isdigit(tempname))));                        num = str2double(tempname(isdigit(tempname)));                        if isempty(num), num=0; end                        if num>=maxnum, maxnum=num+1; end                        foldname=[framefold num2str(maxnum)];                                             else  % name DOES NOT exist                           % do nothing                     end                  end                  mkdir(foldname); cd(foldname)                                    % write the individual frames. We can use QuickTime Pro's nifty                  % "Open Image Sequence..." to make a movie from these frames.                  for i=1:numframes                     eval([ 'temp_frame = frame2im(' which_movie{m} '(i));' ]);                     temp_name = ['frame_' num2str(i) '.' imageformatstr];                     imwrite(temp_frame,temp_name,imageformatstr);                  end               end                              if make_avi                  eval([ 'movie2avi(' which_movie{m} ',fn,''colormap'', tempmap,' ...                     ' ''fps'', fps/movie_speed);' ]);               end                        end           %% switch lower(moviemode(1))      end              %% if pn      cd(old_dir)   end                 %% for m   figure(cfig)         elseif strcmpi(buttName,'hvt_update')   i = cur_sli.Value;   if livemonitor      if plotHOR         wf_overLH.XData=i/samp_freq;         wf_overLH.YData=lhs(i);         wf_overRH.XData=i/samp_freq;         wf_overRH.YData=rhs(i);      end      if plotVRT         wf_overLV.XData=i/samp_freq;         wf_overLV.YData=lvs(i);         wf_overRV.XData=i/samp_freq;         wf_overRV.YData=rvs(i);      end      if plotTOR         wf_overLT.XData=i/samp_freq;         wf_overLT.YData=lts(i);         wf_overRT.XData=i/samp_freq;         wf_overRT.YData=rts(i);      end      if plotXY         % we had to tack some NaN data onto the beginning of the         % array (and shift it) so we can have some history to display.         temp=wf_axXY.Userdata;         xy_val=temp{1};         played_yet=temp{3};         if ~played_yet, return; end                  history      = xy_val{20};         samp_or_sec  = xy_val{21};         ppdata_x = temp{2}{1};         ppdata_y = temp{2}{2};                  if length(ppdata_x)<2, return; end                  history = abs(str2double(history));         if samp_or_sec == 1                       % time            timeshift = round(history*samp_freq);         else                                     % samples            timeshift = round(history);         end         ind=i-startpt+1;         wf_dataXY.XData=ppdata_x(ind:timeshift+ind);         wf_dataXY.YData=ppdata_y(ind:timeshift+ind);         wf_overXY.XData=ppdata_x(timeshift+ind);         wf_overXY.YData=ppdata_y(timeshift+ind);      end   end      elseif strcmpi(buttName,'color')   eyeColor=uisetcolor;   if any(eyeColor)         % so we can use values containing zeros      ebmap=ones(128,3);      eb_size=eb_size_sli.Value;      if eb_size>=0.8         ebmap(127:128,:)=zeros(2,3);         ebmap(119:126,1)=eyeColor(1);         ebmap(119:126,2)=eyeColor(2);         ebmap(119:126,3)=eyeColor(3);      elseif eb_size >= 0.5         ebmap(126:128,:)=zeros(3,3);         ebmap(117:125,1)=eyeColor(1);         ebmap(117:125,2)=eyeColor(2);         ebmap(117:125,3)=eyeColor(3);      end      od.UserData=eyeColor;      efig.Colormap=ebmap;   end      elseif strcmpi(buttName,'crosshairs')   crossHstate = crossH.Value;   if crossHstate==0, newVis='off'; else, newVis='on'; end   chLineH = crossH.UserData;   chLineH(1).Visible=newVis;   chLineH(2).Visible=newVis;   chLineH(3).Visible=newVis;   chLineH(4).Visible=newVis;      elseif strcmpi(buttName,'tormrkr')   val = get(gco,'Value');   if val      osMrkr.Visible='on';      odMrkr.Visible='on';      %set(osMrkr,'MarkerEdgeColor',[1 0 0]);      %set(osMrkr,'MarkerFaceColor',[1 0 0]);      %set(odMrkr,'MarkerEdgeColor',[1 0 0]);      %set(odMrkr,'MarkerFaceColor',[1 0 0]);   else      osMrkr.Visible='off';      odMrkr.Visible='off';      %set(odMrkr,'MarkerEdgeColor','None');      %set(osMrkr,'MarkerEdgeColor','None');      %set(odMrkr,'MarkerFaceColor','None');      %set(osMrkr,'MarkerFaceColor','None');   end      elseif strcmpi(buttName,'wf_draw')   % why was 'wf_draw' called? (could be 'plot h/v/t/pp' checkbox   % or could be result of data scaling. If it is checkbox call   % make sure that at least one checkbox remains checked.   caller=get(gco,'UserData');   value = plotVRTh.Value || plotHORh.Value || ...      plotTORh.Value || plotXYh.Value;      if ~value              % if user is turning off final checkbox      set(gco,'Value',1)  % you can't do that!      %value=value+1;      return   end      % get the window position. we only care about the origin.   figure(wfig);   wfigpos=wfig.Position;      % if there is pre-existing user data in the XY plot axis, retain it.   % we will restore it at the end of this section   % is this necessary?  'datscale' stores offset/scale values in the   % H,V,T (L&R) axes user data. but do we want to save it?  hmmmm.   wf_userD = wfig.UserData;   wH=wf_userD{2}; wf_axXY=wH(13);   xy_ax_userD = gobjects;   if ishandle(wf_axXY)      xy_ax_userD=wf_axXY.UserData;    end   clf      % num_ax, numplanes were calculated at the beginning of ebAct3D   if numplanes==1      wfigmax=[300 280];          %% 255   elseif numplanes==2      wfigmax=[300 540];          %% 507   elseif numplanes==3      wfigmax=[300 670];          %% 640   elseif numplanes==4      wfigmax=[300 810];          %% 780   else      return   end      % since wfig window can be resized, we want to use its CENTER   % (which is saved as 'wf_center' and was used in eb3d to set wfig pos)   % Then we need to calculate new x,y origins based on wfig's center and scale   wf_size = wf_size_sli.Value;   maxwidth=wfigmax(1); maxheight=wfigmax(2);   x0      = wfigpos(1);   y0      = wfigpos(2);   width   = wfigpos(3);    height  = wfigpos(4);   center  = [x0+width/2, y0+height/2];   new_wid = maxwidth*wf_size;   new_hgt = maxheight*wf_size;   new_x0  = center(1)-new_wid/2;   new_y0  = center(2)-new_hgt/2;      wfig.Position=[new_x0, new_y0, new_wid, new_hgt];   wfig.Color=[0.2 0.2 0.2];      ax_units = 'Normalized';   % 'yorig' is y origin for each axis   % majick numbers -- determined by trial and error.   yorig{7} = [0.875 0.765 0.625 0.515 0.375 0.265 0.045];   yorig{6} = [0.85 0.71 0.525 0.385 0.20 0.06];   yorig{5} = [0.83 0.68 0.48 0.33 0.055];   yorig{4} = [0.77 0.56 0.29 0.08];   yorig{3} = [0.74 0.49 0.07];   yorig{2} = [0.53 0.13];   yorig{1} =  0.15;      % 'ht' is height of each axis; 'ppht' is the height of the pp axis   % majick numbers -- determined by trial and error.   ht{7} = 0.09;  ppht{7} = 0.15;   ht{6} = 0.11;   ht{5} = 0.13;  ppht{5} = 0.185;   ht{4} = 0.18;   ht{3} = 0.20;  ppht{3} = 0.30;   ht{2} = 0.35;   ppht{1} = 0.75;      xorig = 0.18; wid = 0.74;      plotSTM=plotSTMh.Value;      % start drawing the desired axes in the wf window.   sub_p=1; wf_ax=gobjects(3,2); wf_over=gobjects(3,2);      chanstr   = {'rhs', 'lhs'; 'rvs', 'lvs'; 'rts', 'lts'};   titlestr  = {'Horizontal'; 'Vertical'; 'Torsional'};   ylabelstr = {['RH (' degstr ')'],['LH (' degstr ')'];...      ['RV (' degstr ')'],['LV (' degstr ')'];...      ['RT (' degstr ')'],['LT (' degstr ')'] };      minval = [minRHS minLHS; minRVS minLVS; minRTS minLTS];   maxval = [maxRHS maxLHS; maxRVS maxLVS; maxRTS maxLTS];   scale  = [rh_scale  lh_scale;  rv_scale  lv_scale;  rt_scale  lt_scale];   offset = [rh_offset lh_offset; rv_offset lv_offset; rt_offset lt_offset];      if wf_size>0.85      titleFSize=14; xyFSize=12;   elseif wf_size>0.7      titleFSize=12; xyFSize=10;   elseif wf_size>0.6      titleFSize=10; xyFSize=8;   elseif wf_size>=0.5      titleFSize=8; xyFSize=6;   end      plotAX(1)=plotHOR; plotAX(2)=plotVRT; plotAX(3)=plotTOR;   stim{1}=st;   stim{2}=sv;   for x=1:3      if plotAX(x)         wf_ax(x,1) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);         if plotSTM && x<3, plot(t,stim{x},'r'); hold on; end         eval([ 'plot(t,' chanstr{x,1} ',''c''); hold on; axis tight; grid' ]);         title(titlestr{x},'FontSize',titleFSize)         ylabel(ylabelstr{x,1},'FontSize',xyFSize)         wf_over(x,1) = plot(NaN, NaN,'wo');         %set(wf_over(x,1),'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')         if minval(x,1)~=maxval(x,1)            wf_ax(x,1).YLim=[minval(x,1) maxval(x,1)];         end         %set(wf_ax(x,1),'UserData',{scale(x,1), offset(x,1) });         wf_ax(x,1).XLim=[startpt/samp_freq stoppt/samp_freq];         wf_ax(x,1).XTickLabel='';         wf_ax(x,1).Units=ax_units;         wf_ax(x,1).Color='k';         sub_p=sub_p+1;                  wf_ax(x,2) = axes('Position',[xorig yorig{num_ax}(sub_p) wid ht{num_ax}]);         if plotSTM && x<3, plot(t,stim{x},'r'); hold on; end         eval([ 'plot(t,' chanstr{x,2} ',''y''); hold on; axis tight; grid' ]);         ylabel(ylabelstr{x,2},'FontSize',xyFSize)         wf_over(x,2) = plot(NaN, NaN,'wo');         %set(wf_over(x,2),'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')         if minval(x,2)~=maxval(x,2)            wf_ax(x,2).YLim=[minval(x,2) maxval(x,2)];         end         %set(wf_ax(x,2),'UserData',{scale(x,2), offset(x,2) });         wf_ax(x,2).XLim=[startpt/samp_freq stoppt/samp_freq];         wf_ax(x,2).Units=ax_units;         wf_ax(x,2).Color='k';         sub_p=sub_p+1;      end   end      wf_axRH=wf_ax(1,1);      wf_axRV=wf_ax(2,1);      wf_axRT=wf_ax(3,1);   wf_axLH=wf_ax(1,2);      wf_axLV=wf_ax(2,2);      wf_axLT=wf_ax(3,2);   wf_overRH=wf_over(1,1);  wf_overRV=wf_over(2,1);  wf_overRT=wf_over(3,1);   wf_overLH=wf_over(1,2);  wf_overLV=wf_over(2,2);  wf_overLT=wf_over(3,2);      % add the xlabel to the final (non XY) axis   if num_ax>1,xlabel('Time (seconds)','FontSize',xyFSize); end      % draw the XY axis   wf_axXY=gobjects; wf_dataXY=gobjects; wf_overXY=gobjects;   if plotXY      % create axis w/appropriate labels      % create empty plot for ppl data to be drawn into      wf_axXY = axes('Position',[xorig yorig{num_ax}(sub_p) wid ppht{num_ax}]);      box; hold on      wf_dataXY = plot(NaN, NaN, 'g');      wf_overXY = plot(NaN, NaN, 'wo');      %set(wf_dataXY,'EraseMode','xor') %%%      %set(wf_overXY,'MarkerSize',6,'EraseMode','xor','MarkerFaceColor','r')      title('XY plot','FontSize',titleFSize)      xlabel('X units','FontSize',xyFSize)      ylabel('Y units','FontSize',xyFSize)      wf_axXY.Units=ax_units;      wf_axXY.Color='k';      wf_axXY.UserData={0,0,0};   end      wH = [wf_axLH wf_overLH wf_axLV wf_overLV wf_axLT wf_overLT,...      wf_axRH wf_overRH wf_axRV wf_overRV wf_axRT wf_overRT,...      wf_axXY wf_dataXY wf_overXY];   wfig.UserData={planes,wH,{offset scale},1};   %% 1: wf_ax_inited      % does updated wf window still have XY plot axis? If so, restore old user data.   if ishandle(wf_axXY)      if ~isempty(xy_ax_userD)         wf_axXY.UserData=xy_ax_userD;      end   end      % if called from 'datscale' make the scaling window the foremost one.   % otherwise bring the controls window to the front   if strcmpi(caller,'ds')      figure(sfig)   else      figure(cfig)   end      elseif strcmpi(buttName,'load_data')   % button already called 'ebdataload' which simply contains the name of   % preferred method to load data (first clearing out the previous data).   % Now we verify that it is valid data. Then must update settings of   % various controls to reflect the properties of the new data.      [status,datlen,noHOR,noVRT,noTOR,noSTM]=ebdatacheck; %#ok<ASGLU>   if noHOR      plotHORh.Enable='off'; plotHORh.Value=0;   else      plotHORh.Enable='on';   end      if noVRT      plotVRTh.Enable='off'; plotVRTh.Value=0;   else      plotVRTh.Enable='on';   end      if noTOR      plotTORh.Enable='off'; plotTORh.Value=0;   else      plotTORh.Enable='on';   end      start_sli.Max=datlen;   cur_sli.Max=datlen;   stop_sli.Max=datlen;   stop_sli.Value=datlen;   stop_txt.String=num2str(datlen);   stop_txt2.String=num2str(datlen/samp_freq);   ebAct3D('wf_draw')      elseif strcmpi(buttName,'movieprefs')   %create a settings window   [movPrefs] = movieprefs(movPrefsBH,playstep);   movPrefsBH.UserData=movPrefs;      elseif strcmpi(buttName,'done!')   cur_dir=pwd;   cd(findomprefs)   efigpos = efig.Position;   cfigpos = cfig.Position;   wfigpos = wfig.Position;   wf_size = wf_size_sli.Value;   eb_size = eb_size_sli.Value;   eyeColor = od.UserData;   wf_center = [ wfigpos(1)+wfigpos(3)/2, wfigpos(2)+wfigpos(4)/2 ];      % get the latest movie making preferences   movtemp = movPrefsBH.UserData;   qtcompressor = movtemp{1};   spatialqual  = movtemp{2};   makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};   movie_speed  = movtemp{5};   make_avi     = movtemp{6};   make_stills  = movtemp{7};      save ebPrefs.mat eyeColor efigpos cfigpos wfigpos wf_center ...      qtcompressor spatialqual makeqtmovie imageformat ...      movie_speed make_avi make_stills eb_size wf_size ...      eyeliner eyelight btxtstr      cd(pathsafe(cur_dir))   uiresume   try delete(efig), catch; end   try delete(cfig), catch; end   try delete(wfig), catch; end   try delete(mfig), catch; end   try delete(sfig), catch; end   try delete(xyfig), catch; end      end  % if strcmpi(buttName ...%*********************************************************************% movieprefs:  a private function in ebAct3D.% Written by:  Jonathan Jacobs%              April 2002 - January 2005 (last mod: 01/19/05)function [movPrefs]=movieprefs(movPrefsBH,playstep)global samp_freqcfig=findwind('Eye Monitor Control');if ~ishandle(cfig)   disp('Eye control window is missing!')   movPrefs=[];   return;endcomp=computer;vers=version;if comp(1)=='M' && vers(1)=='5'   qt_available='on';   qt_flag=1;   avi_available='off'; %avi_flag=0;else   qt_available='off';  qt_flag=0;   avi_available='on';  %avi_flag=1;endmfig=findwind('Movie Prefs');if ~ishandle(mfig)   parent_w_pos=cfig.Position;   mfig_ht=320;   mfig=figure('Resize','off','Menubar','None', ...      'Position',[parent_w_pos(1)+180 parent_w_pos(2)-70 280 mfig_ht],...            'Name','Movie Prefs','NumberTitle','off' );      movtemp=movPrefsBH.UserData;   qtcompressor = movtemp{1};   spatialqual  = movtemp{2};   makeqtmovie  = movtemp{3};   imageformat  = movtemp{4};   movie_speed  = movtemp{5};   make_avi     = movtemp{6};   make_stills  = movtemp{7};      ypos=mfig_ht;   % create the controls   uicontrol(mfig,'Style','frame','Units','pixels',...      'BackgroundColor',[0.25 0.25 0.25],'Position',[2 ypos-110 276 96]);   ypos=ypos-40;      makeqtH = uicontrol('Style','checkbox','Units','pixels',...      'Position',[10 ypos-3 140 25],...      'Tooltip','Make a QuickTime movie',...      'String','Make a QuickTime movie',...      'HorizontalAlignment','center','Enable',qt_available,...      'Value',(makeqtmovie & qt_flag),'Callback',[]);      ypos = ypos-30;   uicontrol(mfig,'Style','text',...      'Position',[20 ypos 120 20],'String','QT codec');   compressH = uicontrol('Style','popup','Units','pixels',...      'Position',[145 ypos-3 120 25],...      'String','video|jpeg|animation',...      'Tooltip','Choose the QT codec',...      'Enable',qt_available,'Value',qtcompressor,...      'HorizontalAlignment','center','Callback',[]);      ypos = ypos-30;   uicontrol(mfig,'Style','text',...      'Position',[20 ypos 120 20],'String','Quality');   spatqualH = uicontrol('Style','popup','Units','pixels',...      'Position',[145 ypos-3 120 25],...      'String','min|low|normal|high|max|lossless',...      'Tooltip','Set the spatial quality',...      'HorizontalAlignment','center',...      'Enable',qt_available,'Value',spatialqual,...      'Callback',[]);      uicontrol(mfig, 'Style','frame','Units','pixels',...      'BackgroundColor',[0.25 0.25 0.25],'Position',[2 ypos-49 276 35]);   ypos=ypos-40;   makeaviH = uicontrol('Style','checkbox','Units','pixels',...      'Position',[10 ypos-3 130 25],...      'Tooltip','Make an AVI movie','String','Make an AVI movie',...      'HorizontalAlignment','center',...      'Enable',avi_available,'Value', make_avi,...      'Callback',[]);      uicontrol(mfig,'Style','frame','Units','pixels',...      'BackgroundColor',[0.25 0.25 0.25],'Position',[2 ypos-80 276 66]);   ypos=ypos-40;   makestillsH = uicontrol('Style','checkbox','Units','pixels',...      'Position',[10 ypos-3 130 25],...      'Tooltip','Make a series of still frames',...      'String','Make a series of images (Use QuickTime Pro to combine)',...      'HorizontalAlignment','center','Value',make_stills,...      'Callback',[]);      ypos = ypos-30;   uicontrol(mfig,'Style','text',...      'Position',[20 ypos 120 20],'String','Still Image Format');   imageformatH = uicontrol('Style','popup','Units','pixels',...      'Position',[145 ypos-3 120 25],'String','jpeg|png|tiff|gif',...      'Tooltip','Choose the format for image frames',...      'HorizontalAlignment','center','Value',imageformat,...      'Callback',[]);      uicontrol(mfig,'Style','frame','Units','pixels',...      'BackgroundColor',[0.25 0.25 0.25],'Position',[2 ypos-80 276 66]);   ypos = ypos-40;   uicontrol(mfig,'Style','text',...      'Position',[10 ypos 110 20],'String','Movie Speed');   moviespeedH = uicontrol(mfig,'Style','edit',...      'Position',[125 ypos 30 20],...      'BackGroundColor','c','ForeGroundColor','k',...      'Tooltip','Duration of AVI or QuickTime movie will be ''x'' times real-time',...      'String',num2str(movie_speed),'Callback',[] );      ypos=ypos-30;   uicontrol(mfig,'Style','text',...      'Position',[10 ypos 110 20],'String','Effective FPS');   %fpsH =    uicontrol(mfig,'Style','text',...      'Position',[125 ypos 30 20],...      'BackGroundColor','c','ForeGroundColor','k',...      'Tooltip','Speed (frames/sec) of AVI or QuickTime movie',...      'String',num2str((samp_freq/playstep)*movie_speed),'Callback',[] );      %doneBH =    uicontrol(mfig,'Style','Pushbutton',...      'Position',[220 5 50 20],'UserData',0,...      'Tooltip','Close this window','String','Done',...      'Callback','uiresume');else   returnend% 'uiwait' will cause the function to wait here until a 'uiresume' is% executed. 'uiresume' is therefore the command issued by the 'done' callbackuiwaitqtcompressor = compressH.Value;spatialqual  = spatqualH.Value;makeqtmovie  = makeqtH.Value;imageformat  = imageformatH.Value;movie_speed  = str2double(moviespeedH.String);make_avi     = makeaviH.Value;make_stills  = makestillsH.Value;movPrefs = {qtcompressor, spatialqual, makeqtmovie, ...   imageformat, movie_speed, make_avi make_stills};movPrefsBH.UserData=movPrefs;close(mfig)%**************************************************************************% mypause.m: a true pause function for delays under a second% Usage: mypause(delay)% where delay is the desired time in milliseconds% NOTE: accuracy is generally good within about 5 ms% Written by:  Jonathan Jacobs%              October 1999  (last mod: 10/19/99)function mypause(delay)diff = 0;tic;while diff*1000 < (delay-0.25)   diff = toc;end