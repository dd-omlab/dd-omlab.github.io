% gDraw.m:  Called by 'draw.m' to draw a line or an arrow.% recognized commands: start, stop, down, move, up% recognized objects:  line, arrow, rectangle, circleS, circleT% Written by:  Jonathan Jacobs%              March 1997 - June 2000 (last mod: 06/25/00)% June 2019: modernized for HG2, improved compatibility with dragger.%    replaced global variables with handle struct, stored in UserDatafunction gDraw(action)gf=findHotW;if strcmpi(gf.Tag,'EditingWindow')   disp('gDraw: Bring a figure window to the front and try again.')   returnendga=gf.CurrentAxes;if isempty(ga),ga=gca;enddeH = findme('drawEditingWindow');if ishandle(deH)   try    h=deH.UserData;   catch, disp('No UserData handles found!'); return   endelse   returnendaxClr=ga.Color;if strcmpi(axClr,'none')   figClr=gf.Color;   if strcmpi(figClr,'none')      tmpLinClr = [1 1 1];   elseif all(figClr==[0 0 0])      tmpLinClr=[1 1 1];   else      tmpLinClr=[0 0 0];   endelseif all(axClr==[0 0 0])   tmpLinClr=[1 1 1];else   tmpLinClr=[0 0 0];endpt=ga.CurrentPoint;if strcmpi(action,'start')   if (h.drawMsg)      disp([h.objtype ' drawing active.'])      disp('Type ''draw'' again to stop drawing.')   end   %xLimMode = get(ga,'XLimMode');   %yLimMode = get(ga,'YLimMode');   ga.XLimMode='manual';   ga.YLimMode='manual';   gf.WindowButtonDownFcn='gDraw(''down'')';   gf.WindowButtonMotionFcn=[];   gf.WindowButtonUpFcn='gDraw(''up'')';   figure(gf)   elseif strcmpi(action,'stop')   if (h.drawMsg)      disp('Drawing stopped.')   end   %set(ga,'XLimMode', xLimMode);   %set(ga,'YLimMode', yLimMode);   gf.WindowButtonDownFcn=[];   gf.WindowButtonMotionFcn=[];   gf.WindowButtonUpFcn=[];   elseif strcmp(action, 'down')   %disp('down!')   gf.WindowButtonMotionFcn='gDraw(''move'')';   gf.Pointer='crosshair';   h.startXPt = pt(1,1);   h.startYPt = pt(1,2);   h.linH = line([NaN,NaN], [NaN, NaN]);   %h.linH.EraseMode='xor';   h.linH.Color=tmpLinClr;   %if ~strcmp(lower(h.objtype),'line')   h.linH.LineStyle=':';   deH.UserData=h;   elseif strcmp(action, 'move')   %disp('move!')   h.newYPt = pt(1,2);   h.newXPt = pt(1,1);   h.linH.XData=[h.startXPt, h.newXPt];   h.linH.YData=[h.startYPt, h.newYPt];   deH.UserData=h;   elseif strcmp(action, 'up')   % this is where we do most of the work.  When the mouse button   % is released we will delete the guide line (except when we are   % actually drawing a line) and then draw the object.   %disp('up!')   h.finalYPt = pt(1,2);   h.finalXPt = pt(1,1);   % check to see if the mouse moved between mouse down and mouse up   % if it didn't then we don't want to draw anything.   if (h.finalXPt==h.startXPt) && (h.finalYPt==h.startYPt)      delete(h.linH)         else % draw something            % writing 'myArrow' was fun. it was an interesting challenge.      if strcmpi(h.objtype,'arrow')         arrowH=myArrow([h.startXPt,h.startYPt],[h.finalXPt,h.finalYPt],...            18,0.5,tmpLinClr); %#ok<NASGU>         %set(arrowH, 'EraseMode', 'xor');         delete(h.linH)               elseif strcmpi(h.objtype, 'line')         % the line is so simple I won't even make a comment         h.linH.LineStyle='-';         h.linH.Color=tmpLinClr;               elseif strcmpi(h.objtype,'circlet')         % technically, this is the eqn for a circle, but         % it will look distorted when drawn on unequal axes.         radius=sqrt( ((h.startXPt-h.finalXPt)/2)^2 +...            ((h.startYPt-h.finalYPt)/2)^2 );         theta = linspace(0,2*pi,300);         xdat = radius*cos(theta)+(h.startXPt+h.finalXPt)/2;         ydat = radius*sin(theta)+(h.startYPt+h.finalYPt)/2;         circH=line(xdat,ydat);         circH.Color=tmpLinClr;         %set(circH, 'EraseMode', 'xor');         delete(h.linH)               elseif strcmpi(h.objtype,'circles')         % this will make a 'corrected' circle which takes         % the different axis scales and lengths into account.         % (This was a _royal_ pain in the ass.)         axDim  = ga.Position;         aspRat = axDim(4)/axDim(3);         xTicks = ga.XTick;         xRange = abs(xTicks(length(xTicks))-xTicks(1));         deltax = h.startXPt-h.finalXPt;         xnorm  = deltax/xRange;         yTicks = ga.YTick;         yRange = abs(yTicks(length(yTicks))-yTicks(1));         deltay = h.startYPt-h.finalYPt;         ynorm  = (deltay/yRange)*aspRat;         if xnorm>0            angle=180/pi*atan(ynorm/xnorm);         else            angle=180/pi*atan(inf);         end         if abs(angle)==90            xx=0;         else            xx=abs(deltax/cos((angle/180)*pi))/2;         end         if angle==0 || abs(angle)==180            yy=0;         else            yy=abs(deltay/sin((angle/180)*pi))/2;         end         if xx==0, xx=yy*(xRange/yRange)*aspRat; end         if yy==0, yy=xx*(yRange/xRange)/aspRat; end         theta = linspace(0,2*pi,300);         xdat = xx*cos(theta) + (h.startXPt+h.finalXPt)/2;         ydat = yy*sin(theta) + (h.startYPt+h.finalYPt)/2;         circH = line(xdat, ydat);         circH.Color=tmpLinClr;         %set(circH, 'EraseMode', 'xor');         delete(h.linH)               elseif strcmpi(h.objtype, 'rectangle')         % this is way too easy for words         rectH = line([h.startXPt h.startXPt h.finalXPt h.finalXPt h.startXPt],...            [h.startYPt h.finalYPt h.finalYPt h.startYPt h.startYPt]);         rectH.Color=tmpLinClr;         %rectH.EraseMode='xor';         delete(h.linH)               elseif strcmpi(h.objtype,'none')         % this is also too easy for words         delete(h.linH)      end %obj type check   end  %mouse up      gf.WindowButtonMotionFcn=[];   gf.Pointer='arrow';end