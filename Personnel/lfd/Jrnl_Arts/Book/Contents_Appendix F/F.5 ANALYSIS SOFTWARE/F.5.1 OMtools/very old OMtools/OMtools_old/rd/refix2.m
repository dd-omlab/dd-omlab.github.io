% refix.m:  use when the subject fixated on targets other than just% at zero degrees.  refix will read in a control file and subtract the % appropriate offsets from the last data record loaded.% written by: Jonathan Jacobs%             December 1995 - December 1996 (last mod: 12/12/96)% load the control file.  it is the name of the selected file, with the% file extension ("dat" or "txt") replaced by a "z"zeroNormFile = [ shortname '.Z' ];disp( ['Reading ' zeroNormFile] )isFile = eval( ['exist(''' zeroNormFile ''')'] );  % " == exist('xxxx.z') "if (~isFile)   disp( ['  <<I can not find the file: ' zeroNormFile '>>'])   disp( ['  <<It must be in the same directory as ' filename '.>>'] )   clear isFile zeroNormFile   returnend[comp, maxsize] = computer;if strcmp( comp, 'MAC2' )   fid = fopen(zeroNormFile, 'r', 'l');   % little-endian else   fid = fopen(zeroNormFile, 'r');        % big-endianendnorm_text = fread(fid);norm_text = setstr(norm_text');fclose(fid);% read in the refixation file ('xxxxxx.Z')% Loop through the entries.  Look for LH horiz or RH horiz data% Use last entries in the "has_LH" and "has_RH" arrays to decide which% data is to be modified (last entry in lh and/or rh).% From start point to stop point, subtract the normalization from the % last loaded position trace(s).maxWid = fix(samp_freq/15);  % 1/15 second widefor k = 1:count       % if the norm file has an lh entry and the just-loaded file has lh data   if ( strcmp(lower(chan_name(count,1:2)),'lh') ) & ( has_LH(length(has_LH)) )       [lhLen lastLH] = size(lh);      normRows = str2num(entries(count,:));      for l=1:normRows                            % each adjustment region         % re-zero the data segment         segment  = (startPt(l,k):stopPt(l,k))';          % make it a column         lh(segment, lastLH) = lh(segment, lastLH) - normVal(l,k);         % now smooth out the discontinuity between segments         % first do the leading edge...         % make sure that 1/8 second before this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = startPt(l,k) - transWid;         if outerPatPt < 1            outerPatPt = 1;            transWid   = startPt(l,k);         end         if startPt(l,k) ~= 1            piece      = lh(outerPatPt:startPt(l,k)-1, lastLH );            endVal     = lh( startPt(l,k), lastLH );            slopes     = ( piece-endVal )./([transWid:-1:1]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + length(slopes) - hits(length(hits));            outerPatPt = startPt(l,k) - transWid;            beginVal   = lh( outerPatPt, lastLH );            patch      = makeptch( lh, outerPatPt, startPt(l,k) );            lh( outerPatPt:startPt(l,k), lastLH ) = patch;         end         % ...and then the trailing edge         % make sure that 1/8 second after this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = stopPt(l,k) + transWid;         if outerPatPt > lhLen            outerPatPt = lhLen;            transWid  = lhLen - stopPt(l,k);         end         if stopPt(l,k) ~= lhLen            piece      = lh(stopPt(l,k)+1:outerPatPt, lastLH);            beginVal   = lh( stopPt(l,k), lastLH );            slopes     = ( piece-beginVal )./([1:transWid]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + hits(1);            outerPatPt = stopPt(l,k) + transWid;            endVal     = lh( outerPatPt, lastLH );            patch      = makeptch( lh, stopPt(l,k), outerPatPt );            lh( stopPt(l,k):outerPatPt, lastLH ) = patch;         end      end %for      disp( '  Found LH refixation corrections.' )      figure( 'NumberT','off','Name',[filename '(lh) after "refix" adjust'] )      plot(lh(:,lastLH))      title( [filename '(LH) after "refix" adjust'] )      if (sac_loaded)         numSPts = length(find(sacp_on_lh(:, lastLH)<100000));         if numSPts            on_lh  = [1; sacp_on_lh(1:numSPts, lastLH); lhLen];            off_lh = [1; sacp_off_lh(1:numSPts, lastLH); lhLen];            hold on            plot( on_lh,  lh(on_lh, lastLH), 'go', 'Marker', 4)               plot( off_lh, lh(off_lh, lastLH), 'co', 'Marker', 4)            end      end      fovrad       end %if has_LH...   % if the norm file has an rh entry and the just-loaded file has rh data   if ( strcmp(lower(chan_name(count,1:2)),'rh') ) & ( has_RH(length(has_RH)) )      [rhLen lastRH] = size(rh);      normRows = str2num(entries(count,:));      for l=1:normRows    % each adjustment region         % re-zero the data segment         segment = (startPt(l,k):stopPt(l,k))';           % make it a column         rh(segment, lastRH) = rh(segment, lastRH) - normVal(l,k);         % now smooth out the discontinuity between segments         % first do the leading edge...         % make sure that 1/8 second before this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = startPt(l,k) - transWid;         if outerPatPt < 1            outerPatPt = 1;            transWid   = startPt(l,k);         end         if startPt(l,k) ~= 1            piece      = rh(outerPatPt:startPt(l,k)-1, lastRH );            endVal     = rh( startPt(l,k), lastRH );            slopes     = ( piece-endVal )./([transWid:-1:1]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + length(slopes) - hits(length(hits));            outerPatPt = startPt(l,k) - transWid;            beginVal   = rh( outerPatPt, lastRH );            patch      = makeptch( rh, outerPatPt, startPt(l,k) );            rh( outerPatPt:startPt(l,k), lastRH ) = patch;         end         % ...and then the trailing edge         % make sure that 1/8 second after this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = stopPt(l,k) + transWid;         if outerPatPt > rhLen            outerPatPt = rhLen;            transWid  = rhLen - stopPt(l,k);         end         if stopPt(l,k) ~= rhLen            piece      = rh(stopPt(l,k)+1:outerPatPt, lastRH);            beginVal   = rh( stopPt(l,k), lastRH );            slopes     = ( piece-beginVal )./([1:transWid]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + hits(1);            outerPatPt = stopPt(l,k) + transWid;            endVal     = rh( outerPatPt, lastRH )            patch      = makeptch( rh, stopPt(l,k), outerPatPt );            rh( stopPt(l,k):outerPatPt, lastRH ) = patch;         end      end %for      disp( '  Found RH refixation corrections.' )      figure( 'NumberT','off','Name',[filename '(RH) after "refix" adjust'] )      plot(rh(:,lastRH))      title( [filename '(RH) after "refix" adjust'] )      if (sac_loaded)         numSPts = length(find(sacp_on_rh(:, lastRH)<100000));         if numSPts            on_rh  = [1; sacp_on_rh(1:numSPts, lastRH); rhLen];            off_rh = [1; sacp_off_rh(1:numSPts, lastRH); rhLen];            hold on            plot( on_rh,  rh(on_rh, lastRH), 'go', 'Marker', 4)               plot( off_rh, rh(off_rh, lastRH), 'co', 'Marker', 4)            end      end      fovrad       end %if has_RH...       % if the norm file has an lv entry and the just-loaded file has lv data   if ( strcmp(lower(chan_name(count,1:2)),'lv') ) & ( has_LV(length(has_LV)) )       [lvLen lastLV] = size(lv);      normRows = str2num(entries(count,:));      for l=1:normRows                            % each adjustment region         % re-zero the data segment         segment  = (startPt(l,k):stopPt(l,k))';          % make it a column         lv(segment, lastLV) = lv(segment, lastLV) - normVal(l,k);         % now smooth out the discontinuity between segments         % first do the leading edge...         % make sure that 1/8 second before this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = startPt(l,k) - transWid;         if outerPatPt < 1            outerPatPt = 1;            transWid   = startPt(l,k);         end         if startPt(l,k) ~= 1            piece      = lv(outerPatPt:startPt(l,k)-1, lastLV );            endVal     = lv( startPt(l,k), lastLV );            slopes     = ( piece-endVal )./([transWid:-1:1]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + length(slopes) - hits(length(hits));            outerPatPt = startPt(l,k) - transWid;            beginVal   = lv( outerPatPt, lastLV );            patch      = makeptch( lv, outerPatPt, startPt(l,k) );            lv( outerPatPt:startPt(l,k), lastLV ) = patch;         end         % ...and then the trailing edge         % make sure that 1/8 second after this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = stopPt(l,k) + transWid;         if outerPatPt > lvLen            outerPatPt = lvLen;            transWid  = lvLen - stopPt(l,k);         end         if stopPt(l,k) ~= lvLen            piece      = lv(stopPt(l,k)+1:outerPatPt, lastLV);            beginVal   = lv( stopPt(l,k), lastLV );            slopes     = ( piece-beginVal )./([1:transWid]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + hits(1);            outerPatPt = stopPt(l,k) + transWid;            endVal     = lv( outerPatPt, lastLV );            patch      = makeptch( lv, stopPt(l,k), outerPatPt );            lv( stopPt(l,k):outerPatPt, lastLV ) = patch;         end      end %for      disp( '  Found LV refixation corrections.' )      figure( 'NumberT','off','Name',[filename '(lv) after "refix" adjust'] )      plot(lv(:,lastLV))      title( [filename '(LV) after "refix" adjust'] )      if (sac_loaded)         numSPts = length(find(sacp_on_lv(:, lastLV)<100000));         if numSPts            on_lv  = [1; sacp_on_lv(1:numSPts, lastLV); lvLen];            off_lv = [1; sacp_off_lv(1:numSPts, lastLV); lvLen];            hold on            plot( on_lv,  lv(on_lv, lastLV), 'go', 'Marker', 4)               plot( off_lv, lv(off_lv, lastLV), 'co', 'Marker', 4)            end      end      fovrad       end %if has_LV...   % if the norm file has an rv entry and the just-loaded file has rv data   if ( strcmp(lower(chan_name(count,1:2)),'rv') ) & ( has_RV(length(has_RV)) )      [rvLen lastRV] = size(rv);      normRows = str2num(entries(count,:));      for l=1:normRows    % each adjustment region         % re-zero the data segment         segment = (startPt(l,k):stopPt(l,k))';           % make it a column         rv(segment, lastRV) = rv(segment, lastRV) - normVal(l,k);         % now smooth out the discontinuity between segments         % first do the leading edge...         % make sure that 1/8 second before this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = startPt(l,k) - transWid;         if outerPatPt < 1            outerPatPt = 1;            transWid   = startPt(l,k);         end         if startPt(l,k) ~= 1            piece      = rv(outerPatPt:startPt(l,k)-1, lastRV );            endVal     = rv( startPt(l,k), lastRV );            slopes     = ( piece-endVal )./([transWid:-1:1]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + length(slopes) - hits(length(hits));            outerPatPt = startPt(l,k) - transWid;            beginVal   = rv( outerPatPt, lastRV );            patch      = makeptch( rv, outerPatPt, startPt(l,k) );            rv( outerPatPt:startPt(l,k), lastRV ) = patch;         end         % ...and then the trailing edge         % make sure that 1/8 second after this segment is not         % beyond the bounds of the data array.         transWid = maxWid;         outerPatPt = stopPt(l,k) + transWid;         if outerPatPt > rvLen            outerPatPt = rvLen;            transWid  = rvLen - stopPt(l,k);         end         if stopPt(l,k) ~= rvLen            piece      = rv(stopPt(l,k)+1:outerPatPt, lastRV);            beginVal   = rv( stopPt(l,k), lastRV );            slopes     = ( piece-beginVal )./([1:transWid]');            minSlope   = min(abs(slopes));            hits       = find(abs(slopes) == minSlope);            transWid   = 1 + hits(1);            outerPatPt = stopPt(l,k) + transWid;            endVal     = rv( outerPatPt, lastRV )            patch      = makeptch( rv, stopPt(l,k), outerPatPt );            rv( stopPt(l,k):outerPatPt, lastRV ) = patch;         end      end %for      disp( '  Found RV refixation corrections.' )      figure( 'NumberT','off','Name',[filename '(RV) after "refix" adjust'] )      plot(rv(:,lastRV))      title( [filename '(RV) after "refix" adjust'] )      if (sac_loaded)         numSPts = length(find(sacp_on_rv(:, lastRV)<100000));         if numSPts            on_rv  = [1; sacp_on_rv(1:numSPts, lastRV); rvLen];            off_rv = [1; sacp_off_rv(1:numSPts, lastRV); rvLen];            hold on            plot( on_rv,  rh(on_rv, lastRV), 'go', 'Marker', 4)               plot( off_rv, rh(off_rv, lastRV), 'co', 'Marker', 4)            end      end      fovrad       end %if has_RV...end %for j...