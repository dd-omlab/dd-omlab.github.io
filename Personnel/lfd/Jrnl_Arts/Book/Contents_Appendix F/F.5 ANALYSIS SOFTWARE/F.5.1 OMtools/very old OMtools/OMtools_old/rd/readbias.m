% readbias.m:  % Read in the necessary adjustments for the data.% For coil data this is just one number, a bias shift.% For IR data there is a bias shift and max, min scale values.% ASCII, ASD & Raw Binary adjust files also contain the sampling frequency.% RTRV, LabVIEW & Ober2 data files already have this info in their header.% If there is a problem, an error flag, biasadj_err_flag is set to 1.% written by: Jonathan Jacobs%             November 1995 - August 2006  (last mod: 08/16/06)% 01/15/04 -- can now properly handle adjbias files with comments inside%  the adjustments block.adjbias_err_flag = 1;disp( ['Loading adjustments from ' adj_fname] )if ~doScaling   disp('*** Scaling will NOT be applied ***')end% 'adj_fname' was determined in getbias.m.  fid = fopen(adj_fname,'r');adjbiastext = fread(fid);adjbiastext = setstr(adjbiastext');fclose(fid);chName = []; adjbias = [];z_adj = []; max_adj = []; min_adj = []; max_cal_pt = []; min_cal_pt = [];% find the filename we are looking for in the adjbias filewhereIsIt = findstr(lower(adjbiastext), deblank(lower(filename)));if isempty(whereIsIt)   disp( 'Couldn''t find this file in my list.' )   adjbias_err_flag = 1;   returnend% get the text FOLLOWING the desired filenameadjbiastext = adjbiastext(whereIsIt:length(adjbiastext)); [topline, adjbiastext, isEmptyLine, isEOF] = getnextl(adjbiastext);[wordlist,numwords] = procline(topline);organization = '';numChan = wordlist(2,:);numChan = str2num(numChan);rectype = lower(deblank(wordlist(3,:)));fileformat = lower(deblank(wordlist(4,:)));% make sure that the adjbias file has the same number% of channels as we found when we read in the data file% this test is not valid for rawbin, so we cheatif strcmp(lower(fileformat),'rawbin')   dat_cols = numChan;   dat_len = numsamps/numChan;endif exist('dat_cols')	if numChan ~= dat_cols	   disp(['Panic! The number of channels listed in bias file (' num2str(numChan) ')' ])	   disp(['does not match the number of channels read from the data (' num2str(dat_cols) ')!'])	   disp('Aborting RD.')	   return	endend% OK, I originally screwed up a bit when I wrote 'biasgen', and did not% put the sampling frequency in the best place.  I originally put it at% the end of EACH channel entry, rather than on the main line, along with% the number of channels, and recording type, etc.% Now 'biasgen' has been modified to do it right, and 'readbias' has been% modified to read either type of bias file.  (03/12/02)samp_flag = 0;switch (fileformat) case {'rawbin','ascii','asyst'}   if numwords >= 5      tempSampFreq = str2num(wordlist(5,:));	  samp_flag = 1;      disp( ['  Sampling frequency: ' num2str(tempSampFreq)] );      disp( ['  Duration of record: ' num2str(dat_len/tempSampFreq) ' seconds'] );   end   if numwords >= 6      organization = lower(deblank(wordlist(6,:)));   endend% initialize min_adj and max_adj arrays to NaNmincalpt = NaN*ones(numChan,10);maxcalpt = NaN*ones(numChan,10);min_adj = ones(numChan,10);max_adj = ones(numChan,10);maxnumcalpts = 0;% clear the arraysc_scale= []; z_adj = [];r_offset = []; r_scale = []; r_calpt = [];rectype = lower(rectype);for i = 1:numChan   robflag = 0;   % ignore comment lines   goodline = 0;   while ~goodline      [topline, adjbiastext, isEmptyLine, isEOF] = getnextl(adjbiastext);      temp=stripcom(topline);      if ~isempty(temp), goodline=1; end   end   [wordlist,numwords] = procline(topline);   chName(i,:) = deblank(wordlist(1,:));   if rectype(1) == 'c' | rectype(1) == 's'      z_adj(i) = str2num(wordlist(2,:));      disp( ['  Channel: ' chName(i,:) '     Bias: ' wordlist(2,:)] )      c_scale(i) = 1;      if numwords >= 3  %% add check here for samp_flag in case of bad (old) adj hdr         c_scale(i) = str2num(wordlist(3,:));         disp( ['                  Scale: ' wordlist(3,:)] )      end           elseif rectype(1) == 'r'      disp( ['  Channel: ' chName(i,:) '     Offset: ' wordlist(2,:)] )      disp( ['                  Scale: ' wordlist(3,:)] )      disp( ['                  Cal Pt: ' wordlist(4,:)] )      robflag = 1;      r_offset(i) = str2num(wordlist(2,:));      r_scale(i) = str2num(wordlist(3,:));      r_calpt(i) = str2num(wordlist(4,:));    elseif rectype(1) == 'i' | rectype(1) == 'v'      % this applies to any method that needs asymmetric calibration      z_adj(i) = str2num(wordlist(2,:));      disp( ['  Channel: ' chName(i,:) '     Offset: ' wordlist(2,:)] )      % how many calibration point pairs are there?      if numwords>5         % assuming equal number of leftward and rightward calibration pts.         % now that 'cal' has been modified, might not be valid assumption         % for time being, 'cal' will pad w/dummy entries if needed. (7/18/02)         numcalpts = fix((numwords-2)/4);         if numcalpts> maxnumcalpts, maxnumcalpts=numcalpts; end	     for j = 1:numcalpts	        maxcalptstr = deblank(wordlist(2+j,:));	        maxcalptstr = maxcalptstr(find(isnumber(maxcalptstr)));	        maxcalpt(i,j) = str2num(maxcalptstr);	        maxadjstr = deblank(wordlist(2+j+numcalpts,:));	        max_adj(i,j) = str2num(maxadjstr(find(isnumber(maxadjstr))));	        disp( ['    Cal pt: ' maxcalptstr  ', scale value: ' maxadjstr])		        mincalptstr = deblank(wordlist(2+(2*numcalpts)+j,:));	        mincalptstr = mincalptstr(find(isnumber(mincalptstr)));	        mincalpt(i,j) = str2num(mincalptstr);	        minadjstr = deblank(wordlist(2+(3*numcalpts)+j,:));	        min_adj(i,j) = str2num(minadjstr(find(isnumber(minadjstr))));            disp( ['    Cal pt: ' mincalptstr  ', scale value: ' minadjstr])         end       else         numcalpts = 1;         maxnumcalpts = 1;         maxadjstr = deblank(wordlist(3,:));         max_adj(i,1) = str2num(maxadjstr);         minadjstr = deblank(wordlist(4,:));         min_adj(i,1) = str2num(minadjstr);         disp( ['    Rightward scale value: ' maxadjstr])	     disp( ['    Leftward scale value: ' minadjstr])      end %%if numword   end  %%for: numchan   % If this is an ASCII or rawbin file then we might need    % to read in the sampling freq (if it was not in the 'right' place.)   % (Retrieve, LabVIEW & Ober2 files store this info in their header.)   if ~samp_flag	   switch lower(fileformat)		  case {'ascii','asyst'}   			 sampfstr = wordlist(numwords,:);			 tempSampFreq = str2num(sampfstr);			 disp( ['  Sampling frequency: ' num2str(tempSampFreq)] );			 disp( ['  Duration of record: ' num2str(dat_len/tempSampFreq) ' seconds'] );		  case {'rawbin'}   		   % This stuff is not needed, since no RAWBIN files were created		   % using the 'wrong' bias file format.		   % sampfstr = wordlist(numwords-1,:);		   % tempSampFreq(i) = str2num(sampfstr);		   % %disp( ['                  Sampling frequency: ' sampfstr] )		   % samp_freq(i) = tempSampFreq(i);		   % %%%%%%%sampfreq = samp_freq(i);		   % % read either 'c' or 'i' for contig/interleaved   				   % organization = wordlist(numwords,:);		   % %disp( ['                  Data organization: ' sampfstr] )	   end   end   end % formaxcalpt = maxcalpt(1:numChan,1:maxnumcalpts);mincalpt = mincalpt(1:numChan,1:maxnumcalpts);max_adj = max_adj(1:numChan,1:maxnumcalpts);min_adj = min_adj(1:numChan,1:maxnumcalpts);z_adj = z_adj';         % make into (numcalpt cols) x (numChan rows)max_adj = max_adj';min_adj = min_adj';adjbias_err_flag = 0;% crufty hack time: if we want to disable scaling (i.e. 'doScaling')% has been disabled in 'enviro', simply make the adjust values 0 & 1if ~doScaling | robflag   z_adj   = zeros(size(z_adj));   max_adj = ones(size(max_adj));   min_adj = ones(size(min_adj));   end